{"version":3,"sources":["index.js","SyncHook.js","Hook.js","HookCodeFactory.js","SyncBailHook.js","SyncWaterfallHook.js","SyncLoopHook.js","AsyncParallelHook.js","AsyncParallelBailHook.js","AsyncSeriesHook.js","AsyncSeriesBailHook.js","AsyncSeriesLoopHook.js","AsyncSeriesWaterfallHook.js","HookMap.js","MultiHook.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,ACHA,AHSA,ADGA;AELA,ACHA,ACHA,AHSA,ADGA;AELA,ACHA,ACHA,AHSA,ADGA;AELA,ACHA,ACHA,AHSA,AIZA,ALeA;AELA,ACHA,ACHA,AHSA,AIZA,ALeA;AELA,ACHA,ACHA,AHSA,AIZA,ALeA;AELA,ACHA,ACHA,AHSA,AKfA,ADGA,ALeA;AELA,ACHA,ACHA,AHSA,AKfA,ADGA,ALeA;AELA,ACHA,ACHA,AHSA,AKfA,ADGA;AELA,ALeA,ACHA,ACHA,AHSA,AKfA,ADGA;AELA,ALeA,ACHA,ACHA,AHSA,AKfA,ADGA;AELA,ALeA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,ALeA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,ALeA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,ALeA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AENA,APqBA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AENA,APqBA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AENA,APqBA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,APqBA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,APqBA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,APqBA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,AT2BA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,AT2BA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,AT2BA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,ACHA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,AT2BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,AT2BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,AT2BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AHSA,AKfA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,ADGA,AGTA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,AENA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,AENA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,AENA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,AENA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,AENA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AV8BA,AENA,ADGA;AGRA,AENA,ADGA,AENA,ACHA,AV8BA,ACHA,AU9BA,ACHA,ARwBA,ADGA;AGRA,AENA,ACHA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AT2BA;AGRA,AENA,ACHA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AT2BA;AGRA,AENA,ACHA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AT2BA;AGRA,AENA,ACHA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AT2BA;AGRA,AENA,ACHA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AT2BA;AGRA,AENA,ACHA,ACHA,AV8BA,ACHA,AU9BA,ACHA,AT2BA;AGRA,AENA,AENA,AV8BA,ACHA,AU9BA,ACHA,AT2BA;AGRA,AENA,AENA,AV8BA,ACHA,AU9BA,ACHA,AT2BA;AGRA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,AIZA,AV8BA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA,ACHA;ANmBA,ANkBA,ACHA,AU9BA;ALgBA,ANkBA,ACHA,AU9BA;ALgBA,ANkBA,ACHA,AU9BA;ALgBA,ANkBA,ACHA,AU9BA;ALgBA,ANkBA,ACHA;AKdA,ANkBA,ACHA;AKdA,ANkBA,ACHA;AKdA,ANkBA,ACHA;AKdA,ANkBA,ACHA;AKdA,ANkBA,ACHA;AKdA,ANkBA,ACHA;AKdA,ANkBA,ACHA;AKdA,ANkBA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nexports.__esModule = true;\nexports.SyncHook = require(\"./SyncHook\");\nexports.SyncBailHook = require(\"./SyncBailHook\");\nexports.SyncWaterfallHook = require(\"./SyncWaterfallHook\");\nexports.SyncLoopHook = require(\"./SyncLoopHook\");\nexports.AsyncParallelHook = require(\"./AsyncParallelHook\");\nexports.AsyncParallelBailHook = require(\"./AsyncParallelBailHook\");\nexports.AsyncSeriesHook = require(\"./AsyncSeriesHook\");\nexports.AsyncSeriesBailHook = require(\"./AsyncSeriesBailHook\");\nexports.AsyncSeriesLoopHook = require(\"./AsyncSeriesLoopHook\");\nexports.AsyncSeriesWaterfallHook = require(\"./AsyncSeriesWaterfallHook\");\nexports.HookMap = require(\"./HookMap\");\nexports.MultiHook = require(\"./MultiHook\");\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nclass SyncHookCodeFactory extends HookCodeFactory {\n\tcontent({ onError, onDone, rethrowIfPossible }) {\n\t\treturn this.callTapsSeries({\n\t\t\tonError: (i, err) => onError(err),\n\t\t\tonDone,\n\t\t\trethrowIfPossible\n\t\t});\n\t}\n}\n\nconst factory = new SyncHookCodeFactory();\n\nconst TAP_ASYNC = () => {\n\tthrow new Error(\"tapAsync is not supported on a SyncHook\");\n};\n\nconst TAP_PROMISE = () => {\n\tthrow new Error(\"tapPromise is not supported on a SyncHook\");\n};\n\nconst COMPILE = function(options) {\n\tfactory.setup(this, options);\n\treturn factory.create(options);\n};\n\nfunction SyncHook(args = [], name = undefined) {\n\tconst hook = new Hook(args, name);\n\thook.constructor = SyncHook;\n\thook.tapAsync = TAP_ASYNC;\n\thook.tapPromise = TAP_PROMISE;\n\thook.compile = COMPILE;\n\treturn hook;\n}\n\nSyncHook.prototype = null;\n\nmodule.exports = SyncHook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst util = require(\"util\");\n\nconst deprecateContext = util.deprecate(() => {},\n\"Hook.context is deprecated and will be removed\");\n\nconst CALL_DELEGATE = function(...args) {\n\tthis.call = this._createCall(\"sync\");\n\treturn this.call(...args);\n};\nconst CALL_ASYNC_DELEGATE = function(...args) {\n\tthis.callAsync = this._createCall(\"async\");\n\treturn this.callAsync(...args);\n};\nconst PROMISE_DELEGATE = function(...args) {\n\tthis.promise = this._createCall(\"promise\");\n\treturn this.promise(...args);\n};\n\nclass Hook {\n\tconstructor(args = [], name = undefined) {\n\t\tthis._args = args;\n\t\tthis.name = name;\n\t\tthis.taps = [];\n\t\tthis.interceptors = [];\n\t\tthis._call = CALL_DELEGATE;\n\t\tthis.call = CALL_DELEGATE;\n\t\tthis._callAsync = CALL_ASYNC_DELEGATE;\n\t\tthis.callAsync = CALL_ASYNC_DELEGATE;\n\t\tthis._promise = PROMISE_DELEGATE;\n\t\tthis.promise = PROMISE_DELEGATE;\n\t\tthis._x = undefined;\n\n\t\tthis.compile = this.compile;\n\t\tthis.tap = this.tap;\n\t\tthis.tapAsync = this.tapAsync;\n\t\tthis.tapPromise = this.tapPromise;\n\t}\n\n\tcompile(options) {\n\t\tthrow new Error(\"Abstract: should be overridden\");\n\t}\n\n\t_createCall(type) {\n\t\treturn this.compile({\n\t\t\ttaps: this.taps,\n\t\t\tinterceptors: this.interceptors,\n\t\t\targs: this._args,\n\t\t\ttype: type\n\t\t});\n\t}\n\n\t_tap(type, options, fn) {\n\t\tif (typeof options === \"string\") {\n\t\t\toptions = {\n\t\t\t\tname: options.trim()\n\t\t\t};\n\t\t} else if (typeof options !== \"object\" || options === null) {\n\t\t\tthrow new Error(\"Invalid tap options\");\n\t\t}\n\t\tif (typeof options.name !== \"string\" || options.name === \"\") {\n\t\t\tthrow new Error(\"Missing name for tap\");\n\t\t}\n\t\tif (typeof options.context !== \"undefined\") {\n\t\t\tdeprecateContext();\n\t\t}\n\t\toptions = Object.assign({ type, fn }, options);\n\t\toptions = this._runRegisterInterceptors(options);\n\t\tthis._insert(options);\n\t}\n\n\ttap(options, fn) {\n\t\tthis._tap(\"sync\", options, fn);\n\t}\n\n\ttapAsync(options, fn) {\n\t\tthis._tap(\"async\", options, fn);\n\t}\n\n\ttapPromise(options, fn) {\n\t\tthis._tap(\"promise\", options, fn);\n\t}\n\n\t_runRegisterInterceptors(options) {\n\t\tfor (const interceptor of this.interceptors) {\n\t\t\tif (interceptor.register) {\n\t\t\t\tconst newOptions = interceptor.register(options);\n\t\t\t\tif (newOptions !== undefined) {\n\t\t\t\t\toptions = newOptions;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\twithOptions(options) {\n\t\tconst mergeOptions = opt =>\n\t\t\tObject.assign({}, options, typeof opt === \"string\" ? { name: opt } : opt);\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\ttap: (opt, fn) => this.tap(mergeOptions(opt), fn),\n\t\t\ttapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),\n\t\t\ttapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),\n\t\t\tintercept: interceptor => this.intercept(interceptor),\n\t\t\tisUsed: () => this.isUsed(),\n\t\t\twithOptions: opt => this.withOptions(mergeOptions(opt))\n\t\t};\n\t}\n\n\tisUsed() {\n\t\treturn this.taps.length > 0 || this.interceptors.length > 0;\n\t}\n\n\tintercept(interceptor) {\n\t\tthis._resetCompilation();\n\t\tthis.interceptors.push(Object.assign({}, interceptor));\n\t\tif (interceptor.register) {\n\t\t\tfor (let i = 0; i < this.taps.length; i++) {\n\t\t\t\tthis.taps[i] = interceptor.register(this.taps[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t_resetCompilation() {\n\t\tthis.call = this._call;\n\t\tthis.callAsync = this._callAsync;\n\t\tthis.promise = this._promise;\n\t}\n\n\t_insert(item) {\n\t\tthis._resetCompilation();\n\t\tlet before;\n\t\tif (typeof item.before === \"string\") {\n\t\t\tbefore = new Set([item.before]);\n\t\t} else if (Array.isArray(item.before)) {\n\t\t\tbefore = new Set(item.before);\n\t\t}\n\t\tlet stage = 0;\n\t\tif (typeof item.stage === \"number\") {\n\t\t\tstage = item.stage;\n\t\t}\n\t\tlet i = this.taps.length;\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tconst x = this.taps[i];\n\t\t\tthis.taps[i + 1] = x;\n\t\t\tconst xStage = x.stage || 0;\n\t\t\tif (before) {\n\t\t\t\tif (before.has(x.name)) {\n\t\t\t\t\tbefore.delete(x.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (before.size > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (xStage > stage) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tthis.taps[i] = item;\n\t}\n}\n\nObject.setPrototypeOf(Hook.prototype, null);\n\nmodule.exports = Hook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nclass HookCodeFactory {\n\tconstructor(config) {\n\t\tthis.config = config;\n\t\tthis.options = undefined;\n\t\tthis._args = undefined;\n\t}\n\n\tcreate(options) {\n\t\tthis.init(options);\n\t\tlet fn;\n\t\tswitch (this.options.type) {\n\t\t\tcase \"sync\":\n\t\t\t\tfn = new Function(\n\t\t\t\t\tthis.args(),\n\t\t\t\t\t'\"use strict\";\\n' +\n\t\t\t\t\t\tthis.header() +\n\t\t\t\t\t\tthis.contentWithInterceptors({\n\t\t\t\t\t\t\tonError: err => `throw ${err};\\n`,\n\t\t\t\t\t\t\tonResult: result => `return ${result};\\n`,\n\t\t\t\t\t\t\tresultReturns: true,\n\t\t\t\t\t\t\tonDone: () => \"\",\n\t\t\t\t\t\t\trethrowIfPossible: true\n\t\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"async\":\n\t\t\t\tfn = new Function(\n\t\t\t\t\tthis.args({\n\t\t\t\t\t\tafter: \"_callback\"\n\t\t\t\t\t}),\n\t\t\t\t\t'\"use strict\";\\n' +\n\t\t\t\t\t\tthis.header() +\n\t\t\t\t\t\tthis.contentWithInterceptors({\n\t\t\t\t\t\t\tonError: err => `_callback(${err});\\n`,\n\t\t\t\t\t\t\tonResult: result => `_callback(null, ${result});\\n`,\n\t\t\t\t\t\t\tonDone: () => \"_callback();\\n\"\n\t\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"promise\":\n\t\t\t\tlet errorHelperUsed = false;\n\t\t\t\tconst content = this.contentWithInterceptors({\n\t\t\t\t\tonError: err => {\n\t\t\t\t\t\terrorHelperUsed = true;\n\t\t\t\t\t\treturn `_error(${err});\\n`;\n\t\t\t\t\t},\n\t\t\t\t\tonResult: result => `_resolve(${result});\\n`,\n\t\t\t\t\tonDone: () => \"_resolve();\\n\"\n\t\t\t\t});\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += '\"use strict\";\\n';\n\t\t\t\tcode += this.header();\n\t\t\t\tcode += \"return new Promise((function(_resolve, _reject) {\\n\";\n\t\t\t\tif (errorHelperUsed) {\n\t\t\t\t\tcode += \"var _sync = true;\\n\";\n\t\t\t\t\tcode += \"function _error(_err) {\\n\";\n\t\t\t\t\tcode += \"if(_sync)\\n\";\n\t\t\t\t\tcode +=\n\t\t\t\t\t\t\"_resolve(Promise.resolve().then((function() { throw _err; })));\\n\";\n\t\t\t\t\tcode += \"else\\n\";\n\t\t\t\t\tcode += \"_reject(_err);\\n\";\n\t\t\t\t\tcode += \"};\\n\";\n\t\t\t\t}\n\t\t\t\tcode += content;\n\t\t\t\tif (errorHelperUsed) {\n\t\t\t\t\tcode += \"_sync = false;\\n\";\n\t\t\t\t}\n\t\t\t\tcode += \"}));\\n\";\n\t\t\t\tfn = new Function(this.args(), code);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.deinit();\n\t\treturn fn;\n\t}\n\n\tsetup(instance, options) {\n\t\tinstance._x = options.taps.map(t => t.fn);\n\t}\n\n\t/**\n\t * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\n\t */\n\tinit(options) {\n\t\tthis.options = options;\n\t\tthis._args = options.args.slice();\n\t}\n\n\tdeinit() {\n\t\tthis.options = undefined;\n\t\tthis._args = undefined;\n\t}\n\n\tcontentWithInterceptors(options) {\n\t\tif (this.options.interceptors.length > 0) {\n\t\t\tconst onError = options.onError;\n\t\t\tconst onResult = options.onResult;\n\t\t\tconst onDone = options.onDone;\n\t\t\tlet code = \"\";\n\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\tif (interceptor.call) {\n\t\t\t\t\tcode += `${this.getInterceptor(i)}.call(${this.args({\n\t\t\t\t\t\tbefore: interceptor.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode += this.content(\n\t\t\t\tObject.assign(options, {\n\t\t\t\t\tonError:\n\t\t\t\t\t\tonError &&\n\t\t\t\t\t\t(err => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\t\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\t\t\t\t\tif (interceptor.error) {\n\t\t\t\t\t\t\t\t\tcode += `${this.getInterceptor(i)}.error(${err});\\n`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcode += onError(err);\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t}),\n\t\t\t\t\tonResult:\n\t\t\t\t\t\tonResult &&\n\t\t\t\t\t\t(result => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\t\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\t\t\t\t\tif (interceptor.result) {\n\t\t\t\t\t\t\t\t\tcode += `${this.getInterceptor(i)}.result(${result});\\n`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcode += onResult(result);\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t}),\n\t\t\t\t\tonDone:\n\t\t\t\t\t\tonDone &&\n\t\t\t\t\t\t(() => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\t\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\t\t\t\t\tif (interceptor.done) {\n\t\t\t\t\t\t\t\t\tcode += `${this.getInterceptor(i)}.done();\\n`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcode += onDone();\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t);\n\t\t\treturn code;\n\t\t} else {\n\t\t\treturn this.content(options);\n\t\t}\n\t}\n\n\theader() {\n\t\tlet code = \"\";\n\t\tif (this.needContext()) {\n\t\t\tcode += \"var _context = {};\\n\";\n\t\t} else {\n\t\t\tcode += \"var _context;\\n\";\n\t\t}\n\t\tcode += \"var _x = this._x;\\n\";\n\t\tif (this.options.interceptors.length > 0) {\n\t\t\tcode += \"var _taps = this.taps;\\n\";\n\t\t\tcode += \"var _interceptors = this.interceptors;\\n\";\n\t\t}\n\t\treturn code;\n\t}\n\n\tneedContext() {\n\t\tfor (const tap of this.options.taps) if (tap.context) return true;\n\t\treturn false;\n\t}\n\n\tcallTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {\n\t\tlet code = \"\";\n\t\tlet hasTapCached = false;\n\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\tif (interceptor.tap) {\n\t\t\t\tif (!hasTapCached) {\n\t\t\t\t\tcode += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\\n`;\n\t\t\t\t\thasTapCached = true;\n\t\t\t\t}\n\t\t\t\tcode += `${this.getInterceptor(i)}.tap(${\n\t\t\t\t\tinterceptor.context ? \"_context, \" : \"\"\n\t\t\t\t}_tap${tapIndex});\\n`;\n\t\t\t}\n\t\t}\n\t\tcode += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\\n`;\n\t\tconst tap = this.options.taps[tapIndex];\n\t\tswitch (tap.type) {\n\t\t\tcase \"sync\":\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += `var _hasError${tapIndex} = false;\\n`;\n\t\t\t\t\tcode += \"try {\\n\";\n\t\t\t\t}\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += `var _result${tapIndex} = _fn${tapIndex}(${this.args({\n\t\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t} else {\n\t\t\t\t\tcode += `_fn${tapIndex}(${this.args({\n\t\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t}\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += \"} catch(_err) {\\n\";\n\t\t\t\t\tcode += `_hasError${tapIndex} = true;\\n`;\n\t\t\t\t\tcode += onError(\"_err\");\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\tcode += `if(!_hasError${tapIndex}) {\\n`;\n\t\t\t\t}\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcode += onDone();\n\t\t\t\t}\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"async\":\n\t\t\t\tlet cbCode = \"\";\n\t\t\t\tif (onResult)\n\t\t\t\t\tcbCode += `(function(_err${tapIndex}, _result${tapIndex}) {\\n`;\n\t\t\t\telse cbCode += `(function(_err${tapIndex}) {\\n`;\n\t\t\t\tcbCode += `if(_err${tapIndex}) {\\n`;\n\t\t\t\tcbCode += onError(`_err${tapIndex}`);\n\t\t\t\tcbCode += \"} else {\\n\";\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcbCode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcbCode += onDone();\n\t\t\t\t}\n\t\t\t\tcbCode += \"}\\n\";\n\t\t\t\tcbCode += \"})\";\n\t\t\t\tcode += `_fn${tapIndex}(${this.args({\n\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined,\n\t\t\t\t\tafter: cbCode\n\t\t\t\t})});\\n`;\n\t\t\t\tbreak;\n\t\t\tcase \"promise\":\n\t\t\t\tcode += `var _hasResult${tapIndex} = false;\\n`;\n\t\t\t\tcode += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({\n\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t})});\\n`;\n\t\t\t\tcode += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\\n`;\n\t\t\t\tcode += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\\n`;\n\t\t\t\tcode += `_promise${tapIndex}.then((function(_result${tapIndex}) {\\n`;\n\t\t\t\tcode += `_hasResult${tapIndex} = true;\\n`;\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcode += onDone();\n\t\t\t\t}\n\t\t\t\tcode += `}), function(_err${tapIndex}) {\\n`;\n\t\t\t\tcode += `if(_hasResult${tapIndex}) throw _err${tapIndex};\\n`;\n\t\t\t\tcode += onError(`_err${tapIndex}`);\n\t\t\t\tcode += \"});\\n\";\n\t\t\t\tbreak;\n\t\t}\n\t\treturn code;\n\t}\n\n\tcallTapsSeries({\n\t\tonError,\n\t\tonResult,\n\t\tresultReturns,\n\t\tonDone,\n\t\tdoneReturns,\n\t\trethrowIfPossible\n\t}) {\n\t\tif (this.options.taps.length === 0) return onDone();\n\t\tconst firstAsync = this.options.taps.findIndex(t => t.type !== \"sync\");\n\t\tconst somethingReturns = resultReturns || doneReturns;\n\t\tlet code = \"\";\n\t\tlet current = onDone;\n\t\tlet unrollCounter = 0;\n\t\tfor (let j = this.options.taps.length - 1; j >= 0; j--) {\n\t\t\tconst i = j;\n\t\t\tconst unroll =\n\t\t\t\tcurrent !== onDone &&\n\t\t\t\t(this.options.taps[i].type !== \"sync\" || unrollCounter++ > 20);\n\t\t\tif (unroll) {\n\t\t\t\tunrollCounter = 0;\n\t\t\t\tcode += `function _next${i}() {\\n`;\n\t\t\t\tcode += current();\n\t\t\t\tcode += `}\\n`;\n\t\t\t\tcurrent = () => `${somethingReturns ? \"return \" : \"\"}_next${i}();\\n`;\n\t\t\t}\n\t\t\tconst done = current;\n\t\t\tconst doneBreak = skipDone => {\n\t\t\t\tif (skipDone) return \"\";\n\t\t\t\treturn onDone();\n\t\t\t};\n\t\t\tconst content = this.callTap(i, {\n\t\t\t\tonError: error => onError(i, error, done, doneBreak),\n\t\t\t\tonResult:\n\t\t\t\t\tonResult &&\n\t\t\t\t\t(result => {\n\t\t\t\t\t\treturn onResult(i, result, done, doneBreak);\n\t\t\t\t\t}),\n\t\t\t\tonDone: !onResult && done,\n\t\t\t\trethrowIfPossible:\n\t\t\t\t\trethrowIfPossible && (firstAsync < 0 || i < firstAsync)\n\t\t\t});\n\t\t\tcurrent = () => content;\n\t\t}\n\t\tcode += current();\n\t\treturn code;\n\t}\n\n\tcallTapsLooping({ onError, onDone, rethrowIfPossible }) {\n\t\tif (this.options.taps.length === 0) return onDone();\n\t\tconst syncOnly = this.options.taps.every(t => t.type === \"sync\");\n\t\tlet code = \"\";\n\t\tif (!syncOnly) {\n\t\t\tcode += \"var _looper = (function() {\\n\";\n\t\t\tcode += \"var _loopAsync = false;\\n\";\n\t\t}\n\t\tcode += \"var _loop;\\n\";\n\t\tcode += \"do {\\n\";\n\t\tcode += \"_loop = false;\\n\";\n\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\tif (interceptor.loop) {\n\t\t\t\tcode += `${this.getInterceptor(i)}.loop(${this.args({\n\t\t\t\t\tbefore: interceptor.context ? \"_context\" : undefined\n\t\t\t\t})});\\n`;\n\t\t\t}\n\t\t}\n\t\tcode += this.callTapsSeries({\n\t\t\tonError,\n\t\t\tonResult: (i, result, next, doneBreak) => {\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += `if(${result} !== undefined) {\\n`;\n\t\t\t\tcode += \"_loop = true;\\n\";\n\t\t\t\tif (!syncOnly) code += \"if(_loopAsync) _looper();\\n\";\n\t\t\t\tcode += doneBreak(true);\n\t\t\t\tcode += `} else {\\n`;\n\t\t\t\tcode += next();\n\t\t\t\tcode += `}\\n`;\n\t\t\t\treturn code;\n\t\t\t},\n\t\t\tonDone:\n\t\t\t\tonDone &&\n\t\t\t\t(() => {\n\t\t\t\t\tlet code = \"\";\n\t\t\t\t\tcode += \"if(!_loop) {\\n\";\n\t\t\t\t\tcode += onDone();\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\treturn code;\n\t\t\t\t}),\n\t\t\trethrowIfPossible: rethrowIfPossible && syncOnly\n\t\t});\n\t\tcode += \"} while(_loop);\\n\";\n\t\tif (!syncOnly) {\n\t\t\tcode += \"_loopAsync = true;\\n\";\n\t\t\tcode += \"});\\n\";\n\t\t\tcode += \"_looper();\\n\";\n\t\t}\n\t\treturn code;\n\t}\n\n\tcallTapsParallel({\n\t\tonError,\n\t\tonResult,\n\t\tonDone,\n\t\trethrowIfPossible,\n\t\tonTap = (i, run) => run()\n\t}) {\n\t\tif (this.options.taps.length <= 1) {\n\t\t\treturn this.callTapsSeries({\n\t\t\t\tonError,\n\t\t\t\tonResult,\n\t\t\t\tonDone,\n\t\t\t\trethrowIfPossible\n\t\t\t});\n\t\t}\n\t\tlet code = \"\";\n\t\tcode += \"do {\\n\";\n\t\tcode += `var _counter = ${this.options.taps.length};\\n`;\n\t\tif (onDone) {\n\t\t\tcode += \"var _done = (function() {\\n\";\n\t\t\tcode += onDone();\n\t\t\tcode += \"});\\n\";\n\t\t}\n\t\tfor (let i = 0; i < this.options.taps.length; i++) {\n\t\t\tconst done = () => {\n\t\t\t\tif (onDone) return \"if(--_counter === 0) _done();\\n\";\n\t\t\t\telse return \"--_counter;\";\n\t\t\t};\n\t\t\tconst doneBreak = skipDone => {\n\t\t\t\tif (skipDone || !onDone) return \"_counter = 0;\\n\";\n\t\t\t\telse return \"_counter = 0;\\n_done();\\n\";\n\t\t\t};\n\t\t\tcode += \"if(_counter <= 0) break;\\n\";\n\t\t\tcode += onTap(\n\t\t\t\ti,\n\t\t\t\t() =>\n\t\t\t\t\tthis.callTap(i, {\n\t\t\t\t\t\tonError: error => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tcode += \"if(_counter > 0) {\\n\";\n\t\t\t\t\t\t\tcode += onError(i, error, done, doneBreak);\n\t\t\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonResult:\n\t\t\t\t\t\t\tonResult &&\n\t\t\t\t\t\t\t(result => {\n\t\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\t\tcode += \"if(_counter > 0) {\\n\";\n\t\t\t\t\t\t\t\tcode += onResult(i, result, done, doneBreak);\n\t\t\t\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\tonDone:\n\t\t\t\t\t\t\t!onResult &&\n\t\t\t\t\t\t\t(() => {\n\t\t\t\t\t\t\t\treturn done();\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\trethrowIfPossible\n\t\t\t\t\t}),\n\t\t\t\tdone,\n\t\t\t\tdoneBreak\n\t\t\t);\n\t\t}\n\t\tcode += \"} while(false);\\n\";\n\t\treturn code;\n\t}\n\n\targs({ before, after } = {}) {\n\t\tlet allArgs = this._args;\n\t\tif (before) allArgs = [before].concat(allArgs);\n\t\tif (after) allArgs = allArgs.concat(after);\n\t\tif (allArgs.length === 0) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn allArgs.join(\", \");\n\t\t}\n\t}\n\n\tgetTapFn(idx) {\n\t\treturn `_x[${idx}]`;\n\t}\n\n\tgetTap(idx) {\n\t\treturn `_taps[${idx}]`;\n\t}\n\n\tgetInterceptor(idx) {\n\t\treturn `_interceptors[${idx}]`;\n\t}\n}\n\nmodule.exports = HookCodeFactory;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nclass SyncBailHookCodeFactory extends HookCodeFactory {\n\tcontent({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {\n\t\treturn this.callTapsSeries({\n\t\t\tonError: (i, err) => onError(err),\n\t\t\tonResult: (i, result, next) =>\n\t\t\t\t`if(${result} !== undefined) {\\n${onResult(\n\t\t\t\t\tresult\n\t\t\t\t)};\\n} else {\\n${next()}}\\n`,\n\t\t\tresultReturns,\n\t\t\tonDone,\n\t\t\trethrowIfPossible\n\t\t});\n\t}\n}\n\nconst factory = new SyncBailHookCodeFactory();\n\nconst TAP_ASYNC = () => {\n\tthrow new Error(\"tapAsync is not supported on a SyncBailHook\");\n};\n\nconst TAP_PROMISE = () => {\n\tthrow new Error(\"tapPromise is not supported on a SyncBailHook\");\n};\n\nconst COMPILE = function(options) {\n\tfactory.setup(this, options);\n\treturn factory.create(options);\n};\n\nfunction SyncBailHook(args = [], name = undefined) {\n\tconst hook = new Hook(args, name);\n\thook.constructor = SyncBailHook;\n\thook.tapAsync = TAP_ASYNC;\n\thook.tapPromise = TAP_PROMISE;\n\thook.compile = COMPILE;\n\treturn hook;\n}\n\nSyncBailHook.prototype = null;\n\nmodule.exports = SyncBailHook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nclass SyncWaterfallHookCodeFactory extends HookCodeFactory {\n\tcontent({ onError, onResult, resultReturns, rethrowIfPossible }) {\n\t\treturn this.callTapsSeries({\n\t\t\tonError: (i, err) => onError(err),\n\t\t\tonResult: (i, result, next) => {\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += `if(${result} !== undefined) {\\n`;\n\t\t\t\tcode += `${this._args[0]} = ${result};\\n`;\n\t\t\t\tcode += `}\\n`;\n\t\t\t\tcode += next();\n\t\t\t\treturn code;\n\t\t\t},\n\t\t\tonDone: () => onResult(this._args[0]),\n\t\t\tdoneReturns: resultReturns,\n\t\t\trethrowIfPossible\n\t\t});\n\t}\n}\n\nconst factory = new SyncWaterfallHookCodeFactory();\n\nconst TAP_ASYNC = () => {\n\tthrow new Error(\"tapAsync is not supported on a SyncWaterfallHook\");\n};\n\nconst TAP_PROMISE = () => {\n\tthrow new Error(\"tapPromise is not supported on a SyncWaterfallHook\");\n};\n\nconst COMPILE = function(options) {\n\tfactory.setup(this, options);\n\treturn factory.create(options);\n};\n\nfunction SyncWaterfallHook(args = [], name = undefined) {\n\tif (args.length < 1)\n\t\tthrow new Error(\"Waterfall hooks must have at least one argument\");\n\tconst hook = new Hook(args, name);\n\thook.constructor = SyncWaterfallHook;\n\thook.tapAsync = TAP_ASYNC;\n\thook.tapPromise = TAP_PROMISE;\n\thook.compile = COMPILE;\n\treturn hook;\n}\n\nSyncWaterfallHook.prototype = null;\n\nmodule.exports = SyncWaterfallHook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nclass SyncLoopHookCodeFactory extends HookCodeFactory {\n\tcontent({ onError, onDone, rethrowIfPossible }) {\n\t\treturn this.callTapsLooping({\n\t\t\tonError: (i, err) => onError(err),\n\t\t\tonDone,\n\t\t\trethrowIfPossible\n\t\t});\n\t}\n}\n\nconst factory = new SyncLoopHookCodeFactory();\n\nconst TAP_ASYNC = () => {\n\tthrow new Error(\"tapAsync is not supported on a SyncLoopHook\");\n};\n\nconst TAP_PROMISE = () => {\n\tthrow new Error(\"tapPromise is not supported on a SyncLoopHook\");\n};\n\nconst COMPILE = function(options) {\n\tfactory.setup(this, options);\n\treturn factory.create(options);\n};\n\nfunction SyncLoopHook(args = [], name = undefined) {\n\tconst hook = new Hook(args, name);\n\thook.constructor = SyncLoopHook;\n\thook.tapAsync = TAP_ASYNC;\n\thook.tapPromise = TAP_PROMISE;\n\thook.compile = COMPILE;\n\treturn hook;\n}\n\nSyncLoopHook.prototype = null;\n\nmodule.exports = SyncLoopHook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nclass AsyncParallelHookCodeFactory extends HookCodeFactory {\n\tcontent({ onError, onDone }) {\n\t\treturn this.callTapsParallel({\n\t\t\tonError: (i, err, done, doneBreak) => onError(err) + doneBreak(true),\n\t\t\tonDone\n\t\t});\n\t}\n}\n\nconst factory = new AsyncParallelHookCodeFactory();\n\nconst COMPILE = function(options) {\n\tfactory.setup(this, options);\n\treturn factory.create(options);\n};\n\nfunction AsyncParallelHook(args = [], name = undefined) {\n\tconst hook = new Hook(args, name);\n\thook.constructor = AsyncParallelHook;\n\thook.compile = COMPILE;\n\thook._call = undefined;\n\thook.call = undefined;\n\treturn hook;\n}\n\nAsyncParallelHook.prototype = null;\n\nmodule.exports = AsyncParallelHook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nclass AsyncParallelBailHookCodeFactory extends HookCodeFactory {\n\tcontent({ onError, onResult, onDone }) {\n\t\tlet code = \"\";\n\t\tcode += `var _results = new Array(${this.options.taps.length});\\n`;\n\t\tcode += \"var _checkDone = function() {\\n\";\n\t\tcode += \"for(var i = 0; i < _results.length; i++) {\\n\";\n\t\tcode += \"var item = _results[i];\\n\";\n\t\tcode += \"if(item === undefined) return false;\\n\";\n\t\tcode += \"if(item.result !== undefined) {\\n\";\n\t\tcode += onResult(\"item.result\");\n\t\tcode += \"return true;\\n\";\n\t\tcode += \"}\\n\";\n\t\tcode += \"if(item.error) {\\n\";\n\t\tcode += onError(\"item.error\");\n\t\tcode += \"return true;\\n\";\n\t\tcode += \"}\\n\";\n\t\tcode += \"}\\n\";\n\t\tcode += \"return false;\\n\";\n\t\tcode += \"}\\n\";\n\t\tcode += this.callTapsParallel({\n\t\t\tonError: (i, err, done, doneBreak) => {\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += `if(${i} < _results.length && ((_results.length = ${i +\n\t\t\t\t\t1}), (_results[${i}] = { error: ${err} }), _checkDone())) {\\n`;\n\t\t\t\tcode += doneBreak(true);\n\t\t\t\tcode += \"} else {\\n\";\n\t\t\t\tcode += done();\n\t\t\t\tcode += \"}\\n\";\n\t\t\t\treturn code;\n\t\t\t},\n\t\t\tonResult: (i, result, done, doneBreak) => {\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i +\n\t\t\t\t\t1}), (_results[${i}] = { result: ${result} }), _checkDone())) {\\n`;\n\t\t\t\tcode += doneBreak(true);\n\t\t\t\tcode += \"} else {\\n\";\n\t\t\t\tcode += done();\n\t\t\t\tcode += \"}\\n\";\n\t\t\t\treturn code;\n\t\t\t},\n\t\t\tonTap: (i, run, done, doneBreak) => {\n\t\t\t\tlet code = \"\";\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tcode += `if(${i} >= _results.length) {\\n`;\n\t\t\t\t\tcode += done();\n\t\t\t\t\tcode += \"} else {\\n\";\n\t\t\t\t}\n\t\t\t\tcode += run();\n\t\t\t\tif (i > 0) code += \"}\\n\";\n\t\t\t\treturn code;\n\t\t\t},\n\t\t\tonDone\n\t\t});\n\t\treturn code;\n\t}\n}\n\nconst factory = new AsyncParallelBailHookCodeFactory();\n\nconst COMPILE = function(options) {\n\tfactory.setup(this, options);\n\treturn factory.create(options);\n};\n\nfunction AsyncParallelBailHook(args = [], name = undefined) {\n\tconst hook = new Hook(args, name);\n\thook.constructor = AsyncParallelBailHook;\n\thook.compile = COMPILE;\n\thook._call = undefined;\n\thook.call = undefined;\n\treturn hook;\n}\n\nAsyncParallelBailHook.prototype = null;\n\nmodule.exports = AsyncParallelBailHook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nclass AsyncSeriesHookCodeFactory extends HookCodeFactory {\n\tcontent({ onError, onDone }) {\n\t\treturn this.callTapsSeries({\n\t\t\tonError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),\n\t\t\tonDone\n\t\t});\n\t}\n}\n\nconst factory = new AsyncSeriesHookCodeFactory();\n\nconst COMPILE = function(options) {\n\tfactory.setup(this, options);\n\treturn factory.create(options);\n};\n\nfunction AsyncSeriesHook(args = [], name = undefined) {\n\tconst hook = new Hook(args, name);\n\thook.constructor = AsyncSeriesHook;\n\thook.compile = COMPILE;\n\thook._call = undefined;\n\thook.call = undefined;\n\treturn hook;\n}\n\nAsyncSeriesHook.prototype = null;\n\nmodule.exports = AsyncSeriesHook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nclass AsyncSeriesBailHookCodeFactory extends HookCodeFactory {\n\tcontent({ onError, onResult, resultReturns, onDone }) {\n\t\treturn this.callTapsSeries({\n\t\t\tonError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),\n\t\t\tonResult: (i, result, next) =>\n\t\t\t\t`if(${result} !== undefined) {\\n${onResult(\n\t\t\t\t\tresult\n\t\t\t\t)}\\n} else {\\n${next()}}\\n`,\n\t\t\tresultReturns,\n\t\t\tonDone\n\t\t});\n\t}\n}\n\nconst factory = new AsyncSeriesBailHookCodeFactory();\n\nconst COMPILE = function(options) {\n\tfactory.setup(this, options);\n\treturn factory.create(options);\n};\n\nfunction AsyncSeriesBailHook(args = [], name = undefined) {\n\tconst hook = new Hook(args, name);\n\thook.constructor = AsyncSeriesBailHook;\n\thook.compile = COMPILE;\n\thook._call = undefined;\n\thook.call = undefined;\n\treturn hook;\n}\n\nAsyncSeriesBailHook.prototype = null;\n\nmodule.exports = AsyncSeriesBailHook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nclass AsyncSeriesLoopHookCodeFactory extends HookCodeFactory {\n\tcontent({ onError, onDone }) {\n\t\treturn this.callTapsLooping({\n\t\t\tonError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),\n\t\t\tonDone\n\t\t});\n\t}\n}\n\nconst factory = new AsyncSeriesLoopHookCodeFactory();\n\nconst COMPILE = function(options) {\n\tfactory.setup(this, options);\n\treturn factory.create(options);\n};\n\nfunction AsyncSeriesLoopHook(args = [], name = undefined) {\n\tconst hook = new Hook(args, name);\n\thook.constructor = AsyncSeriesLoopHook;\n\thook.compile = COMPILE;\n\thook._call = undefined;\n\thook.call = undefined;\n\treturn hook;\n}\n\nAsyncSeriesLoopHook.prototype = null;\n\nmodule.exports = AsyncSeriesLoopHook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\nconst HookCodeFactory = require(\"./HookCodeFactory\");\n\nclass AsyncSeriesWaterfallHookCodeFactory extends HookCodeFactory {\n\tcontent({ onError, onResult, onDone }) {\n\t\treturn this.callTapsSeries({\n\t\t\tonError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),\n\t\t\tonResult: (i, result, next) => {\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += `if(${result} !== undefined) {\\n`;\n\t\t\t\tcode += `${this._args[0]} = ${result};\\n`;\n\t\t\t\tcode += `}\\n`;\n\t\t\t\tcode += next();\n\t\t\t\treturn code;\n\t\t\t},\n\t\t\tonDone: () => onResult(this._args[0])\n\t\t});\n\t}\n}\n\nconst factory = new AsyncSeriesWaterfallHookCodeFactory();\n\nconst COMPILE = function(options) {\n\tfactory.setup(this, options);\n\treturn factory.create(options);\n};\n\nfunction AsyncSeriesWaterfallHook(args = [], name = undefined) {\n\tif (args.length < 1)\n\t\tthrow new Error(\"Waterfall hooks must have at least one argument\");\n\tconst hook = new Hook(args, name);\n\thook.constructor = AsyncSeriesWaterfallHook;\n\thook.compile = COMPILE;\n\thook._call = undefined;\n\thook.call = undefined;\n\treturn hook;\n}\n\nAsyncSeriesWaterfallHook.prototype = null;\n\nmodule.exports = AsyncSeriesWaterfallHook;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst util = require(\"util\");\n\nconst defaultFactory = (key, hook) => hook;\n\nclass HookMap {\n\tconstructor(factory, name = undefined) {\n\t\tthis._map = new Map();\n\t\tthis.name = name;\n\t\tthis._factory = factory;\n\t\tthis._interceptors = [];\n\t}\n\n\tget(key) {\n\t\treturn this._map.get(key);\n\t}\n\n\tfor(key) {\n\t\tconst hook = this.get(key);\n\t\tif (hook !== undefined) {\n\t\t\treturn hook;\n\t\t}\n\t\tlet newHook = this._factory(key);\n\t\tconst interceptors = this._interceptors;\n\t\tfor (let i = 0; i < interceptors.length; i++) {\n\t\t\tnewHook = interceptors[i].factory(key, newHook);\n\t\t}\n\t\tthis._map.set(key, newHook);\n\t\treturn newHook;\n\t}\n\n\tintercept(interceptor) {\n\t\tthis._interceptors.push(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\tfactory: defaultFactory\n\t\t\t\t},\n\t\t\t\tinterceptor\n\t\t\t)\n\t\t);\n\t}\n}\n\nHookMap.prototype.tap = util.deprecate(function(key, options, fn) {\n\treturn this.for(key).tap(options, fn);\n}, \"HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead.\");\n\nHookMap.prototype.tapAsync = util.deprecate(function(key, options, fn) {\n\treturn this.for(key).tapAsync(options, fn);\n}, \"HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead.\");\n\nHookMap.prototype.tapPromise = util.deprecate(function(key, options, fn) {\n\treturn this.for(key).tapPromise(options, fn);\n}, \"HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead.\");\n\nmodule.exports = HookMap;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst Hook = require(\"./Hook\");\n\nclass MultiHook {\n\tconstructor(hooks, name = undefined) {\n\t\tthis.hooks = hooks;\n\t\tthis.name = name;\n\t}\n\n\ttap(options, fn) {\n\t\tfor (const hook of this.hooks) {\n\t\t\thook.tap(options, fn);\n\t\t}\n\t}\n\n\ttapAsync(options, fn) {\n\t\tfor (const hook of this.hooks) {\n\t\t\thook.tapAsync(options, fn);\n\t\t}\n\t}\n\n\ttapPromise(options, fn) {\n\t\tfor (const hook of this.hooks) {\n\t\t\thook.tapPromise(options, fn);\n\t\t}\n\t}\n\n\tisUsed() {\n\t\tfor (const hook of this.hooks) {\n\t\t\tif (hook.isUsed()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tintercept(interceptor) {\n\t\tfor (const hook of this.hooks) {\n\t\t\thook.intercept(interceptor);\n\t\t}\n\t}\n\n\twithOptions(options) {\n\t\treturn new MultiHook(\n\t\t\tthis.hooks.map(h => h.withOptions(options)),\n\t\t\tthis.name\n\t\t);\n\t}\n}\n\nmodule.exports = MultiHook;\n"]}