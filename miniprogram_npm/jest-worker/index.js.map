{"version":3,"sources":["index.js","Farm.js","FifoQueue.js","types.js","PriorityQueue.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,ACHA,AENA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nObject.defineProperty(exports, 'FifoQueue', {\n  enumerable: true,\n  get: function () {\n    return _FifoQueue.default;\n  }\n});\nObject.defineProperty(exports, 'PriorityQueue', {\n  enumerable: true,\n  get: function () {\n    return _PriorityQueue.default;\n  }\n});\nexports.Worker = void 0;\nObject.defineProperty(exports, 'messageParent', {\n  enumerable: true,\n  get: function () {\n    return _messageParent.default;\n  }\n});\n\nfunction _os() {\n  const data = require('os');\n\n  _os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _Farm = _interopRequireDefault(require('./Farm'));\n\nvar _WorkerPool = _interopRequireDefault(require('./WorkerPool'));\n\nvar _PriorityQueue = _interopRequireDefault(require('./PriorityQueue'));\n\nvar _FifoQueue = _interopRequireDefault(require('./FifoQueue'));\n\nvar _messageParent = _interopRequireDefault(require('./workers/messageParent'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction getExposedMethods(workerPath, options) {\n  let exposedMethods = options.exposedMethods; // If no methods list is given, try getting it by auto-requiring the module.\n\n  if (!exposedMethods) {\n    const module = require(workerPath);\n\n    exposedMethods = Object.keys(module).filter(\n      // @ts-expect-error: no index\n      name => typeof module[name] === 'function'\n    );\n\n    if (typeof module === 'function') {\n      exposedMethods = [...exposedMethods, 'default'];\n    }\n  }\n\n  return exposedMethods;\n}\n/**\n * The Jest farm (publicly called \"Worker\") is a class that allows you to queue\n * methods across multiple child processes, in order to parallelize work. This\n * is done by providing an absolute path to a module that will be loaded on each\n * of the child processes, and bridged to the main process.\n *\n * Bridged methods are specified by using the \"exposedMethods\" property of the\n * \"options\" object. This is an array of strings, where each of them corresponds\n * to the exported name in the loaded module.\n *\n * You can also control the amount of workers by using the \"numWorkers\" property\n * of the \"options\" object, and the settings passed to fork the process through\n * the \"forkOptions\" property. The amount of workers defaults to the amount of\n * CPUS minus one.\n *\n * Queueing calls can be done in two ways:\n *   - Standard method: calls will be redirected to the first available worker,\n *     so they will get executed as soon as they can.\n *\n *   - Sticky method: if a \"computeWorkerKey\" method is provided within the\n *     config, the resulting string of this method will be used as a key.\n *     Every time this key is returned, it is guaranteed that your job will be\n *     processed by the same worker. This is specially useful if your workers\n *     are caching results.\n */\n\nclass Worker {\n  constructor(workerPath, options) {\n    var _this$_options$enable,\n      _this$_options$forkOp,\n      _this$_options$maxRet,\n      _this$_options$numWor,\n      _this$_options$resour,\n      _this$_options$setupA;\n\n    _defineProperty(this, '_ending', void 0);\n\n    _defineProperty(this, '_farm', void 0);\n\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_workerPool', void 0);\n\n    this._options = {...options};\n    this._ending = false;\n    const workerPoolOptions = {\n      enableWorkerThreads:\n        (_this$_options$enable = this._options.enableWorkerThreads) !== null &&\n        _this$_options$enable !== void 0\n          ? _this$_options$enable\n          : false,\n      forkOptions:\n        (_this$_options$forkOp = this._options.forkOptions) !== null &&\n        _this$_options$forkOp !== void 0\n          ? _this$_options$forkOp\n          : {},\n      maxRetries:\n        (_this$_options$maxRet = this._options.maxRetries) !== null &&\n        _this$_options$maxRet !== void 0\n          ? _this$_options$maxRet\n          : 3,\n      numWorkers:\n        (_this$_options$numWor = this._options.numWorkers) !== null &&\n        _this$_options$numWor !== void 0\n          ? _this$_options$numWor\n          : Math.max((0, _os().cpus)().length - 1, 1),\n      resourceLimits:\n        (_this$_options$resour = this._options.resourceLimits) !== null &&\n        _this$_options$resour !== void 0\n          ? _this$_options$resour\n          : {},\n      setupArgs:\n        (_this$_options$setupA = this._options.setupArgs) !== null &&\n        _this$_options$setupA !== void 0\n          ? _this$_options$setupA\n          : []\n    };\n\n    if (this._options.WorkerPool) {\n      // @ts-expect-error: constructor target any?\n      this._workerPool = new this._options.WorkerPool(\n        workerPath,\n        workerPoolOptions\n      );\n    } else {\n      this._workerPool = new _WorkerPool.default(workerPath, workerPoolOptions);\n    }\n\n    this._farm = new _Farm.default(\n      workerPoolOptions.numWorkers,\n      this._workerPool.send.bind(this._workerPool),\n      {\n        computeWorkerKey: this._options.computeWorkerKey,\n        taskQueue: this._options.taskQueue,\n        workerSchedulingPolicy: this._options.workerSchedulingPolicy\n      }\n    );\n\n    this._bindExposedWorkerMethods(workerPath, this._options);\n  }\n\n  _bindExposedWorkerMethods(workerPath, options) {\n    getExposedMethods(workerPath, options).forEach(name => {\n      if (name.startsWith('_')) {\n        return;\n      }\n\n      if (this.constructor.prototype.hasOwnProperty(name)) {\n        throw new TypeError('Cannot define a method called ' + name);\n      } // @ts-expect-error: dynamic extension of the class instance is expected.\n\n      this[name] = this._callFunctionWithArgs.bind(this, name);\n    });\n  }\n\n  _callFunctionWithArgs(method, ...args) {\n    if (this._ending) {\n      throw new Error('Farm is ended, no more calls can be done to it');\n    }\n\n    return this._farm.doWork(method, ...args);\n  }\n\n  getStderr() {\n    return this._workerPool.getStderr();\n  }\n\n  getStdout() {\n    return this._workerPool.getStdout();\n  }\n\n  async end() {\n    if (this._ending) {\n      throw new Error('Farm is ended, no more calls can be done to it');\n    }\n\n    this._ending = true;\n    return this._workerPool.end();\n  }\n}\n\nexports.Worker = Worker;\n","\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _FifoQueue = _interopRequireDefault(require('./FifoQueue'));\n\nvar _types = require('./types');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nclass Farm {\n  constructor(_numOfWorkers, _callback, options = {}) {\n    var _options$workerSchedu, _options$taskQueue;\n\n    _defineProperty(this, '_computeWorkerKey', void 0);\n\n    _defineProperty(this, '_workerSchedulingPolicy', void 0);\n\n    _defineProperty(this, '_cacheKeys', Object.create(null));\n\n    _defineProperty(this, '_locks', []);\n\n    _defineProperty(this, '_offset', 0);\n\n    _defineProperty(this, '_taskQueue', void 0);\n\n    this._numOfWorkers = _numOfWorkers;\n    this._callback = _callback;\n    this._computeWorkerKey = options.computeWorkerKey;\n    this._workerSchedulingPolicy =\n      (_options$workerSchedu = options.workerSchedulingPolicy) !== null &&\n      _options$workerSchedu !== void 0\n        ? _options$workerSchedu\n        : 'round-robin';\n    this._taskQueue =\n      (_options$taskQueue = options.taskQueue) !== null &&\n      _options$taskQueue !== void 0\n        ? _options$taskQueue\n        : new _FifoQueue.default();\n  }\n\n  doWork(method, ...args) {\n    const customMessageListeners = new Set();\n\n    const addCustomMessageListener = listener => {\n      customMessageListeners.add(listener);\n      return () => {\n        customMessageListeners.delete(listener);\n      };\n    };\n\n    const onCustomMessage = message => {\n      customMessageListeners.forEach(listener => listener(message));\n    };\n\n    const promise = new Promise( // Bind args to this function so it won't reference to the parent scope.\n      // This prevents a memory leak in v8, because otherwise the function will\n      // retaine args for the closure.\n      ((args, resolve, reject) => {\n        const computeWorkerKey = this._computeWorkerKey;\n        const request = [_types.CHILD_MESSAGE_CALL, false, method, args];\n        let worker = null;\n        let hash = null;\n\n        if (computeWorkerKey) {\n          hash = computeWorkerKey.call(this, method, ...args);\n          worker = hash == null ? null : this._cacheKeys[hash];\n        }\n\n        const onStart = worker => {\n          if (hash != null) {\n            this._cacheKeys[hash] = worker;\n          }\n        };\n\n        const onEnd = (error, result) => {\n          customMessageListeners.clear();\n\n          if (error) {\n            reject(error);\n          } else {\n            resolve(result);\n          }\n        };\n\n        const task = {\n          onCustomMessage,\n          onEnd,\n          onStart,\n          request\n        };\n\n        if (worker) {\n          this._taskQueue.enqueue(task, worker.getWorkerId());\n\n          this._process(worker.getWorkerId());\n        } else {\n          this._push(task);\n        }\n      }).bind(null, args)\n    );\n    promise.UNSTABLE_onCustomMessage = addCustomMessageListener;\n    return promise;\n  }\n\n  _process(workerId) {\n    if (this._isLocked(workerId)) {\n      return this;\n    }\n\n    const task = this._taskQueue.dequeue(workerId);\n\n    if (!task) {\n      return this;\n    }\n\n    if (task.request[1]) {\n      throw new Error('Queue implementation returned processed task');\n    } // Reference the task object outside so it won't be retained by onEnd,\n    // and other properties of the task object, such as task.request can be\n    // garbage collected.\n\n    const taskOnEnd = task.onEnd;\n\n    const onEnd = (error, result) => {\n      taskOnEnd(error, result);\n\n      this._unlock(workerId);\n\n      this._process(workerId);\n    };\n\n    task.request[1] = true;\n\n    this._lock(workerId);\n\n    this._callback(\n      workerId,\n      task.request,\n      task.onStart,\n      onEnd,\n      task.onCustomMessage\n    );\n\n    return this;\n  }\n\n  _push(task) {\n    this._taskQueue.enqueue(task);\n\n    const offset = this._getNextWorkerOffset();\n\n    for (let i = 0; i < this._numOfWorkers; i++) {\n      this._process((offset + i) % this._numOfWorkers);\n\n      if (task.request[1]) {\n        break;\n      }\n    }\n\n    return this;\n  }\n\n  _getNextWorkerOffset() {\n    switch (this._workerSchedulingPolicy) {\n      case 'in-order':\n        return 0;\n\n      case 'round-robin':\n        return this._offset++;\n    }\n  }\n\n  _lock(workerId) {\n    this._locks[workerId] = true;\n  }\n\n  _unlock(workerId) {\n    this._locks[workerId] = false;\n  }\n\n  _isLocked(workerId) {\n    return this._locks[workerId];\n  }\n}\n\nexports.default = Farm;\n","\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * First-in, First-out task queue that manages a dedicated pool\n * for each worker as well as a shared queue. The FIFO ordering is guaranteed\n * across the worker specific and shared queue.\n */\nclass FifoQueue {\n  constructor() {\n    _defineProperty(this, '_workerQueues', []);\n\n    _defineProperty(this, '_sharedQueue', new InternalQueue());\n  }\n\n  enqueue(task, workerId) {\n    if (workerId == null) {\n      this._sharedQueue.enqueue(task);\n\n      return;\n    }\n\n    let workerQueue = this._workerQueues[workerId];\n\n    if (workerQueue == null) {\n      workerQueue = this._workerQueues[workerId] = new InternalQueue();\n    }\n\n    const sharedTop = this._sharedQueue.peekLast();\n\n    const item = {\n      previousSharedTask: sharedTop,\n      task\n    };\n    workerQueue.enqueue(item);\n  }\n\n  dequeue(workerId) {\n    var _this$_workerQueues$w, _workerTop$previousSh, _workerTop$previousSh2;\n\n    const workerTop =\n      (_this$_workerQueues$w = this._workerQueues[workerId]) === null ||\n      _this$_workerQueues$w === void 0\n        ? void 0\n        : _this$_workerQueues$w.peek();\n    const sharedTaskIsProcessed =\n      (_workerTop$previousSh =\n        workerTop === null || workerTop === void 0\n          ? void 0\n          : (_workerTop$previousSh2 = workerTop.previousSharedTask) === null ||\n            _workerTop$previousSh2 === void 0\n          ? void 0\n          : _workerTop$previousSh2.request[1]) !== null &&\n      _workerTop$previousSh !== void 0\n        ? _workerTop$previousSh\n        : true; // Process the top task from the shared queue if\n    // - there's no task in the worker specific queue or\n    // - if the non-worker-specific task after which this worker specifif task\n    //   hasn been queued wasn't processed yet\n\n    if (workerTop != null && sharedTaskIsProcessed) {\n      var _this$_workerQueues$w2,\n        _this$_workerQueues$w3,\n        _this$_workerQueues$w4;\n\n      return (_this$_workerQueues$w2 =\n        (_this$_workerQueues$w3 = this._workerQueues[workerId]) === null ||\n        _this$_workerQueues$w3 === void 0\n          ? void 0\n          : (_this$_workerQueues$w4 = _this$_workerQueues$w3.dequeue()) ===\n              null || _this$_workerQueues$w4 === void 0\n          ? void 0\n          : _this$_workerQueues$w4.task) !== null &&\n        _this$_workerQueues$w2 !== void 0\n        ? _this$_workerQueues$w2\n        : null;\n    }\n\n    return this._sharedQueue.dequeue();\n  }\n}\n\nexports.default = FifoQueue;\n\n/**\n * FIFO queue for a single worker / shared queue.\n */\nclass InternalQueue {\n  constructor() {\n    _defineProperty(this, '_head', null);\n\n    _defineProperty(this, '_last', null);\n  }\n\n  enqueue(value) {\n    const item = {\n      next: null,\n      value\n    };\n\n    if (this._last == null) {\n      this._head = item;\n    } else {\n      this._last.next = item;\n    }\n\n    this._last = item;\n  }\n\n  dequeue() {\n    if (this._head == null) {\n      return null;\n    }\n\n    const item = this._head;\n    this._head = item.next;\n\n    if (this._head == null) {\n      this._last = null;\n    }\n\n    return item.value;\n  }\n\n  peek() {\n    var _this$_head$value, _this$_head;\n\n    return (_this$_head$value =\n      (_this$_head = this._head) === null || _this$_head === void 0\n        ? void 0\n        : _this$_head.value) !== null && _this$_head$value !== void 0\n      ? _this$_head$value\n      : null;\n  }\n\n  peekLast() {\n    var _this$_last$value, _this$_last;\n\n    return (_this$_last$value =\n      (_this$_last = this._last) === null || _this$_last === void 0\n        ? void 0\n        : _this$_last.value) !== null && _this$_last$value !== void 0\n      ? _this$_last$value\n      : null;\n  }\n}\n","\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.PARENT_MESSAGE_SETUP_ERROR =\n  exports.PARENT_MESSAGE_OK =\n  exports.PARENT_MESSAGE_CUSTOM =\n  exports.PARENT_MESSAGE_CLIENT_ERROR =\n  exports.CHILD_MESSAGE_INITIALIZE =\n  exports.CHILD_MESSAGE_END =\n  exports.CHILD_MESSAGE_CALL =\n    void 0;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// import type {ResourceLimits} from 'worker_threads';\n// This is not present in the Node 12 typings\n// Because of the dynamic nature of a worker communication process, all messages\n// coming from any of the other processes cannot be typed. Thus, many types\n// include \"unknown\" as a TS type, which is (unfortunately) correct here.\nconst CHILD_MESSAGE_INITIALIZE = 0;\nexports.CHILD_MESSAGE_INITIALIZE = CHILD_MESSAGE_INITIALIZE;\nconst CHILD_MESSAGE_CALL = 1;\nexports.CHILD_MESSAGE_CALL = CHILD_MESSAGE_CALL;\nconst CHILD_MESSAGE_END = 2;\nexports.CHILD_MESSAGE_END = CHILD_MESSAGE_END;\nconst PARENT_MESSAGE_OK = 0;\nexports.PARENT_MESSAGE_OK = PARENT_MESSAGE_OK;\nconst PARENT_MESSAGE_CLIENT_ERROR = 1;\nexports.PARENT_MESSAGE_CLIENT_ERROR = PARENT_MESSAGE_CLIENT_ERROR;\nconst PARENT_MESSAGE_SETUP_ERROR = 2;\nexports.PARENT_MESSAGE_SETUP_ERROR = PARENT_MESSAGE_SETUP_ERROR;\nconst PARENT_MESSAGE_CUSTOM = 3;\nexports.PARENT_MESSAGE_CUSTOM = PARENT_MESSAGE_CUSTOM;\n","\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Priority queue that processes tasks in natural ordering (lower priority first)\n * accoridng to the priority computed by the function passed in the constructor.\n *\n * FIFO ordering isn't guaranteed for tasks with the same priority.\n *\n * Worker specific tasks with the same priority as a non-worker specific task\n * are always processed first.\n */\nclass PriorityQueue {\n  constructor(_computePriority) {\n    _defineProperty(this, '_queue', []);\n\n    _defineProperty(this, '_sharedQueue', new MinHeap());\n\n    this._computePriority = _computePriority;\n  }\n\n  enqueue(task, workerId) {\n    if (workerId == null) {\n      this._enqueue(task, this._sharedQueue);\n    } else {\n      const queue = this._getWorkerQueue(workerId);\n\n      this._enqueue(task, queue);\n    }\n  }\n\n  _enqueue(task, queue) {\n    const item = {\n      priority: this._computePriority(task.request[2], ...task.request[3]),\n      task\n    };\n    queue.add(item);\n  }\n\n  dequeue(workerId) {\n    const workerQueue = this._getWorkerQueue(workerId);\n\n    const workerTop = workerQueue.peek();\n\n    const sharedTop = this._sharedQueue.peek(); // use the task from the worker queue if there's no task in the shared queue\n    // or if the priority of the worker queue is smaller or equal to the\n    // priority of the top task in the shared queue. The tasks of the\n    // worker specific queue are preferred because no other worker can pick this\n    // specific task up.\n\n    if (\n      sharedTop == null ||\n      (workerTop != null && workerTop.priority <= sharedTop.priority)\n    ) {\n      var _workerQueue$poll$tas, _workerQueue$poll;\n\n      return (_workerQueue$poll$tas =\n        (_workerQueue$poll = workerQueue.poll()) === null ||\n        _workerQueue$poll === void 0\n          ? void 0\n          : _workerQueue$poll.task) !== null && _workerQueue$poll$tas !== void 0\n        ? _workerQueue$poll$tas\n        : null;\n    }\n\n    return this._sharedQueue.poll().task;\n  }\n\n  _getWorkerQueue(workerId) {\n    let queue = this._queue[workerId];\n\n    if (queue == null) {\n      queue = this._queue[workerId] = new MinHeap();\n    }\n\n    return queue;\n  }\n}\n\nexports.default = PriorityQueue;\n\nclass MinHeap {\n  constructor() {\n    _defineProperty(this, '_heap', []);\n  }\n\n  peek() {\n    var _this$_heap$;\n\n    return (_this$_heap$ = this._heap[0]) !== null && _this$_heap$ !== void 0\n      ? _this$_heap$\n      : null;\n  }\n\n  add(item) {\n    const nodes = this._heap;\n    nodes.push(item);\n\n    if (nodes.length === 1) {\n      return;\n    }\n\n    let currentIndex = nodes.length - 1; // Bubble up the added node as long as the parent is bigger\n\n    while (currentIndex > 0) {\n      const parentIndex = Math.floor((currentIndex + 1) / 2) - 1;\n      const parent = nodes[parentIndex];\n\n      if (parent.priority <= item.priority) {\n        break;\n      }\n\n      nodes[currentIndex] = parent;\n      nodes[parentIndex] = item;\n      currentIndex = parentIndex;\n    }\n  }\n\n  poll() {\n    const nodes = this._heap;\n    const result = nodes[0];\n    const lastElement = nodes.pop(); // heap was empty or removed the last element\n\n    if (result == null || nodes.length === 0) {\n      return result !== null && result !== void 0 ? result : null;\n    }\n\n    let index = 0;\n    nodes[0] =\n      lastElement !== null && lastElement !== void 0 ? lastElement : null;\n    const element = nodes[0];\n\n    while (true) {\n      let swapIndex = null;\n      const rightChildIndex = (index + 1) * 2;\n      const leftChildIndex = rightChildIndex - 1;\n      const rightChild = nodes[rightChildIndex];\n      const leftChild = nodes[leftChildIndex]; // if the left child is smaller, swap with the left\n\n      if (leftChild != null && leftChild.priority < element.priority) {\n        swapIndex = leftChildIndex;\n      } // If the right child is smaller or the right child is smaller than the left\n      // then swap with the right child\n\n      if (\n        rightChild != null &&\n        rightChild.priority < (swapIndex == null ? element : leftChild).priority\n      ) {\n        swapIndex = rightChildIndex;\n      }\n\n      if (swapIndex == null) {\n        break;\n      }\n\n      nodes[index] = nodes[swapIndex];\n      nodes[swapIndex] = element;\n      index = swapIndex;\n    }\n\n    return result;\n  }\n}\n"]}