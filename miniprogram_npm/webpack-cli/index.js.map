{"version":3,"sources":["index.js","webpack-cli.js","utils/dynamic-import-loader.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const CLI = require(\"./webpack-cli\");\n\nmodule.exports = CLI;\n// TODO remove after drop `@webpack-cli/migrate`\nmodule.exports.utils = { logger: console };\n","const fs = require(\"fs\");\nconst path = require(\"path\");\nconst { pathToFileURL } = require(\"url\");\nconst util = require(\"util\");\n\nconst { program, Option } = require(\"commander\");\n\nconst WEBPACK_PACKAGE = process.env.WEBPACK_PACKAGE || \"webpack\";\nconst WEBPACK_DEV_SERVER_PACKAGE = process.env.WEBPACK_DEV_SERVER_PACKAGE || \"webpack-dev-server\";\n\nclass WebpackCLI {\n  constructor() {\n    this.colors = this.createColors();\n    this.logger = this.getLogger();\n\n    // Initialize program\n    this.program = program;\n    this.program.name(\"webpack\");\n    this.program.configureOutput({\n      writeErr: this.logger.error,\n      outputError: (str, write) =>\n        write(`Error: ${this.capitalizeFirstLetter(str.replace(/^error:/, \"\").trim())}`),\n    });\n  }\n\n  capitalizeFirstLetter(str) {\n    if (typeof str !== \"string\") {\n      return \"\";\n    }\n\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  toKebabCase(str) {\n    return str.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n  }\n\n  createColors(useColor) {\n    const { createColors, isColorSupported } = require(\"colorette\");\n\n    let shouldUseColor;\n\n    if (useColor) {\n      shouldUseColor = useColor;\n    } else {\n      shouldUseColor = isColorSupported;\n    }\n\n    return { ...createColors({ useColor: shouldUseColor }), isColorSupported: shouldUseColor };\n  }\n\n  getLogger() {\n    return {\n      error: (val) => console.error(`[webpack-cli] ${this.colors.red(util.format(val))}`),\n      warn: (val) => console.warn(`[webpack-cli] ${this.colors.yellow(val)}`),\n      info: (val) => console.info(`[webpack-cli] ${this.colors.cyan(val)}`),\n      success: (val) => console.log(`[webpack-cli] ${this.colors.green(val)}`),\n      log: (val) => console.log(`[webpack-cli] ${val}`),\n      raw: (val) => console.log(val),\n    };\n  }\n\n  checkPackageExists(packageName) {\n    if (process.versions.pnp) {\n      return true;\n    }\n\n    let dir = __dirname;\n\n    do {\n      try {\n        if (fs.statSync(path.join(dir, \"node_modules\", packageName)).isDirectory()) {\n          return true;\n        }\n      } catch (_error) {\n        // Nothing\n      }\n    } while (dir !== (dir = path.dirname(dir)));\n\n    return false;\n  }\n\n  getAvailablePackageManagers() {\n    const { sync } = require(\"execa\");\n    const installers = [\"npm\", \"yarn\", \"pnpm\"];\n    const hasPackageManagerInstalled = (packageManager) => {\n      try {\n        sync(packageManager, [\"--version\"]);\n\n        return packageManager;\n      } catch (err) {\n        return false;\n      }\n    };\n    const availableInstallers = installers.filter((installer) =>\n      hasPackageManagerInstalled(installer),\n    );\n\n    if (!availableInstallers.length) {\n      this.logger.error(\"No package manager found.\");\n\n      process.exit(2);\n    }\n\n    return availableInstallers;\n  }\n\n  getDefaultPackageManager() {\n    const { sync } = require(\"execa\");\n    const hasLocalNpm = fs.existsSync(path.resolve(process.cwd(), \"package-lock.json\"));\n\n    if (hasLocalNpm) {\n      return \"npm\";\n    }\n\n    const hasLocalYarn = fs.existsSync(path.resolve(process.cwd(), \"yarn.lock\"));\n\n    if (hasLocalYarn) {\n      return \"yarn\";\n    }\n\n    const hasLocalPnpm = fs.existsSync(path.resolve(process.cwd(), \"pnpm-lock.yaml\"));\n\n    if (hasLocalPnpm) {\n      return \"pnpm\";\n    }\n\n    try {\n      // the sync function below will fail if npm is not installed,\n      // an error will be thrown\n      if (sync(\"npm\", [\"--version\"])) {\n        return \"npm\";\n      }\n    } catch (e) {\n      // Nothing\n    }\n\n    try {\n      // the sync function below will fail if yarn is not installed,\n      // an error will be thrown\n      if (sync(\"yarn\", [\"--version\"])) {\n        return \"yarn\";\n      }\n    } catch (e) {\n      // Nothing\n    }\n\n    try {\n      // the sync function below will fail if pnpm is not installed,\n      // an error will be thrown\n      if (sync(\"pnpm\", [\"--version\"])) {\n        return \"pnpm\";\n      }\n    } catch (e) {\n      this.logger.error(\"No package manager found.\");\n\n      process.exit(2);\n    }\n  }\n\n  async doInstall(packageName, options = {}) {\n    const packageManager = this.getDefaultPackageManager();\n\n    if (!packageManager) {\n      this.logger.error(\"Can't find package manager\");\n\n      process.exit(2);\n    }\n\n    if (options.preMessage) {\n      options.preMessage();\n    }\n\n    // yarn uses 'add' command, rest npm and pnpm both use 'install'\n    const commandToBeRun = `${packageManager} ${[\n      packageManager === \"yarn\" ? \"add\" : \"install\",\n      \"-D\",\n      packageName,\n    ].join(\" \")}`;\n\n    const prompt = ({ message, defaultResponse, stream }) => {\n      const readline = require(\"readline\");\n      const rl = readline.createInterface({\n        input: process.stdin,\n        output: stream,\n      });\n\n      return new Promise((resolve) => {\n        rl.question(`${message} `, (answer) => {\n          // Close the stream\n          rl.close();\n\n          const response = (answer || defaultResponse).toLowerCase();\n\n          // Resolve with the input response\n          if (response === \"y\" || response === \"yes\") {\n            resolve(true);\n          } else {\n            resolve(false);\n          }\n        });\n      });\n    };\n\n    let needInstall;\n\n    try {\n      needInstall = await prompt({\n        message: `[webpack-cli] Would you like to install '${this.colors.green(\n          packageName,\n        )}' package? (That will run '${this.colors.green(commandToBeRun)}') (${this.colors.yellow(\n          \"Y/n\",\n        )})`,\n        defaultResponse: \"Y\",\n        stream: process.stderr,\n      });\n    } catch (error) {\n      this.logger.error(error);\n\n      process.exit(error);\n    }\n\n    if (needInstall) {\n      const execa = require(\"execa\");\n\n      try {\n        await execa(commandToBeRun, [], { stdio: \"inherit\", shell: true });\n      } catch (error) {\n        this.logger.error(error);\n\n        process.exit(2);\n      }\n\n      return packageName;\n    }\n\n    process.exit(2);\n  }\n\n  async tryRequireThenImport(module, handleError = true) {\n    let result;\n\n    try {\n      result = require(module);\n    } catch (error) {\n      const dynamicImportLoader = require(\"./utils/dynamic-import-loader\")();\n      if (\n        (error.code === \"ERR_REQUIRE_ESM\" || process.env.WEBPACK_CLI_FORCE_LOAD_ESM_CONFIG) &&\n        pathToFileURL &&\n        dynamicImportLoader\n      ) {\n        const urlForConfig = pathToFileURL(module);\n\n        result = await dynamicImportLoader(urlForConfig);\n        result = result.default;\n\n        return result;\n      }\n\n      if (handleError) {\n        this.logger.error(error);\n        process.exit(2);\n      } else {\n        throw error;\n      }\n    }\n\n    // For babel/typescript\n    if (result && typeof result === \"object\" && \"default\" in result) {\n      result = result.default || {};\n    }\n\n    return result || {};\n  }\n\n  loadJSONFile(pathToFile, handleError = true) {\n    let result;\n\n    try {\n      result = require(pathToFile);\n    } catch (error) {\n      if (handleError) {\n        this.logger.error(error);\n        process.exit(2);\n      } else {\n        throw error;\n      }\n    }\n\n    return result;\n  }\n\n  async makeCommand(commandOptions, options, action) {\n    const alreadyLoaded = this.program.commands.find(\n      (command) =>\n        command.name() === commandOptions.name.split(\" \")[0] ||\n        command.aliases().includes(commandOptions.alias),\n    );\n\n    if (alreadyLoaded) {\n      return;\n    }\n\n    const command = this.program.command(commandOptions.name, {\n      noHelp: commandOptions.noHelp,\n      hidden: commandOptions.hidden,\n      isDefault: commandOptions.isDefault,\n    });\n\n    if (commandOptions.description) {\n      command.description(commandOptions.description, commandOptions.argsDescription);\n    }\n\n    if (commandOptions.usage) {\n      command.usage(commandOptions.usage);\n    }\n\n    if (Array.isArray(commandOptions.alias)) {\n      command.aliases(commandOptions.alias);\n    } else {\n      command.alias(commandOptions.alias);\n    }\n\n    if (commandOptions.pkg) {\n      command.pkg = commandOptions.pkg;\n    } else {\n      command.pkg = \"webpack-cli\";\n    }\n\n    const { forHelp } = this.program;\n\n    let allDependenciesInstalled = true;\n\n    if (commandOptions.dependencies && commandOptions.dependencies.length > 0) {\n      for (const dependency of commandOptions.dependencies) {\n        const isPkgExist = this.checkPackageExists(dependency);\n\n        if (isPkgExist) {\n          continue;\n        } else if (!isPkgExist && forHelp) {\n          allDependenciesInstalled = false;\n          continue;\n        }\n\n        let skipInstallation = false;\n\n        // Allow to use `./path/to/webpack.js` outside `node_modules`\n        if (dependency === WEBPACK_PACKAGE && fs.existsSync(WEBPACK_PACKAGE)) {\n          skipInstallation = true;\n        }\n\n        // Allow to use `./path/to/webpack-dev-server.js` outside `node_modules`\n        if (dependency === WEBPACK_DEV_SERVER_PACKAGE && fs.existsSync(WEBPACK_PACKAGE)) {\n          skipInstallation = true;\n        }\n\n        if (skipInstallation) {\n          continue;\n        }\n\n        await this.doInstall(dependency, {\n          preMessage: () => {\n            this.logger.error(\n              `For using '${this.colors.green(\n                commandOptions.name.split(\" \")[0],\n              )}' command you need to install: '${this.colors.green(dependency)}' package.`,\n            );\n          },\n        });\n      }\n    }\n\n    if (options) {\n      if (typeof options === \"function\") {\n        if (forHelp && !allDependenciesInstalled) {\n          command.description(\n            `${\n              commandOptions.description\n            } To see all available options you need to install ${commandOptions.dependencies\n              .map((dependency) => `'${dependency}'`)\n              .join(\", \")}.`,\n          );\n          options = [];\n        } else {\n          options = await options();\n        }\n      }\n\n      options.forEach((optionForCommand) => {\n        this.makeOption(command, optionForCommand);\n      });\n    }\n\n    command.action(action);\n\n    return command;\n  }\n\n  makeOption(command, option) {\n    let mainOption;\n    let negativeOption;\n\n    if (option.configs) {\n      let needNegativeOption = false;\n      let negatedDescription;\n      const mainOptionType = new Set();\n\n      option.configs.forEach((config) => {\n        // Possible value: \"enum\" | \"string\" | \"path\" | \"number\" | \"boolean\" | \"RegExp\" | \"reset\"\n        switch (config.type) {\n          case \"reset\":\n            mainOptionType.add(Boolean);\n            break;\n          case \"boolean\":\n            if (!needNegativeOption) {\n              needNegativeOption = true;\n              negatedDescription = config.negatedDescription;\n            }\n\n            mainOptionType.add(Boolean);\n            break;\n          case \"number\":\n            mainOptionType.add(Number);\n            break;\n          case \"string\":\n          case \"path\":\n          case \"RegExp\":\n            mainOptionType.add(String);\n            break;\n          case \"enum\": {\n            let hasFalseEnum = false;\n\n            const enumTypes = config.values.map((value) => {\n              switch (typeof value) {\n                case \"string\":\n                  mainOptionType.add(String);\n                  break;\n                case \"number\":\n                  mainOptionType.add(Number);\n                  break;\n                case \"boolean\":\n                  if (!hasFalseEnum && value === false) {\n                    hasFalseEnum = true;\n                    break;\n                  }\n\n                  mainOptionType.add(Boolean);\n                  break;\n              }\n            });\n\n            if (!needNegativeOption) {\n              needNegativeOption = hasFalseEnum;\n              negatedDescription = config.negatedDescription;\n            }\n\n            return enumTypes;\n          }\n        }\n      });\n\n      mainOption = {\n        flags: option.alias ? `-${option.alias}, --${option.name}` : `--${option.name}`,\n        description: option.description || \"\",\n        type: mainOptionType,\n        multiple: option.multiple,\n        defaultValue: option.defaultValue,\n      };\n\n      if (needNegativeOption) {\n        negativeOption = {\n          flags: `--no-${option.name}`,\n          description:\n            negatedDescription || option.negatedDescription || `Negative '${option.name}' option.`,\n        };\n      }\n    } else {\n      mainOption = {\n        flags: option.alias ? `-${option.alias}, --${option.name}` : `--${option.name}`,\n        // TODO `describe` used by `webpack-dev-server@3`\n        description: option.description || option.describe || \"\",\n        type: option.type\n          ? new Set(Array.isArray(option.type) ? option.type : [option.type])\n          : new Set([Boolean]),\n        multiple: option.multiple,\n        defaultValue: option.defaultValue,\n      };\n\n      if (option.negative) {\n        negativeOption = {\n          flags: `--no-${option.name}`,\n          description: option.negatedDescription\n            ? option.negatedDescription\n            : `Negative '${option.name}' option.`,\n        };\n      }\n    }\n\n    if (mainOption.type.size > 1 && mainOption.type.has(Boolean)) {\n      mainOption.flags = `${mainOption.flags} [value${mainOption.multiple ? \"...\" : \"\"}]`;\n    } else if (mainOption.type.size > 0 && !mainOption.type.has(Boolean)) {\n      mainOption.flags = `${mainOption.flags} <value${mainOption.multiple ? \"...\" : \"\"}>`;\n    }\n\n    if (mainOption.type.size === 1) {\n      if (mainOption.type.has(Number)) {\n        let skipDefault = true;\n\n        const optionForCommand = new Option(mainOption.flags, mainOption.description)\n          .argParser((value, prev = []) => {\n            if (mainOption.defaultValue && mainOption.multiple && skipDefault) {\n              prev = [];\n              skipDefault = false;\n            }\n\n            return mainOption.multiple ? [].concat(prev).concat(Number(value)) : Number(value);\n          })\n          .default(mainOption.defaultValue);\n\n        optionForCommand.helpLevel = option.helpLevel;\n\n        command.addOption(optionForCommand);\n      } else if (mainOption.type.has(String)) {\n        let skipDefault = true;\n\n        const optionForCommand = new Option(mainOption.flags, mainOption.description)\n          .argParser((value, prev = []) => {\n            if (mainOption.defaultValue && mainOption.multiple && skipDefault) {\n              prev = [];\n              skipDefault = false;\n            }\n\n            return mainOption.multiple ? [].concat(prev).concat(value) : value;\n          })\n          .default(mainOption.defaultValue);\n\n        optionForCommand.helpLevel = option.helpLevel;\n\n        command.addOption(optionForCommand);\n      } else if (mainOption.type.has(Boolean)) {\n        const optionForCommand = new Option(mainOption.flags, mainOption.description).default(\n          mainOption.defaultValue,\n        );\n\n        optionForCommand.helpLevel = option.helpLevel;\n\n        command.addOption(optionForCommand);\n      } else {\n        const optionForCommand = new Option(mainOption.flags, mainOption.description)\n          .argParser(Array.from(mainOption.type)[0])\n          .default(mainOption.defaultValue);\n\n        optionForCommand.helpLevel = option.helpLevel;\n\n        command.addOption(optionForCommand);\n      }\n    } else if (mainOption.type.size > 1) {\n      let skipDefault = true;\n\n      const optionForCommand = new Option(\n        mainOption.flags,\n        mainOption.description,\n        mainOption.defaultValue,\n      )\n        .argParser((value, prev = []) => {\n          if (mainOption.defaultValue && mainOption.multiple && skipDefault) {\n            prev = [];\n            skipDefault = false;\n          }\n\n          if (mainOption.type.has(Number)) {\n            const numberValue = Number(value);\n\n            if (!isNaN(numberValue)) {\n              return mainOption.multiple ? [].concat(prev).concat(numberValue) : numberValue;\n            }\n          }\n\n          if (mainOption.type.has(String)) {\n            return mainOption.multiple ? [].concat(prev).concat(value) : value;\n          }\n\n          return value;\n        })\n        .default(mainOption.defaultValue);\n\n      optionForCommand.helpLevel = option.helpLevel;\n\n      command.addOption(optionForCommand);\n    } else if (mainOption.type.size === 0 && negativeOption) {\n      const optionForCommand = new Option(mainOption.flags, mainOption.description);\n\n      // Hide stub option\n      optionForCommand.hideHelp();\n      optionForCommand.helpLevel = option.helpLevel;\n\n      command.addOption(optionForCommand);\n    }\n\n    if (negativeOption) {\n      const optionForCommand = new Option(negativeOption.flags, negativeOption.description);\n\n      optionForCommand.helpLevel = option.helpLevel;\n\n      command.addOption(optionForCommand);\n    }\n  }\n\n  getBuiltInOptions() {\n    if (this.builtInOptionsCache) {\n      return this.builtInOptionsCache;\n    }\n\n    const minimumHelpFlags = [\n      \"config\",\n      \"config-name\",\n      \"merge\",\n      \"env\",\n      \"mode\",\n      \"watch\",\n      \"watch-options-stdin\",\n      \"stats\",\n      \"devtool\",\n      \"entry\",\n      \"target\",\n      \"progress\",\n      \"json\",\n      \"name\",\n      \"output-path\",\n      \"node-env\",\n    ];\n\n    const builtInFlags = [\n      // For configs\n      {\n        name: \"config\",\n        alias: \"c\",\n        configs: [\n          {\n            type: \"string\",\n          },\n        ],\n        multiple: true,\n        description: \"Provide path to a webpack configuration file e.g. ./webpack.config.js.\",\n      },\n      {\n        name: \"config-name\",\n        configs: [\n          {\n            type: \"string\",\n          },\n        ],\n        multiple: true,\n        description: \"Name of the configuration to use.\",\n      },\n      {\n        name: \"merge\",\n        alias: \"m\",\n        configs: [\n          {\n            type: \"enum\",\n            values: [true],\n          },\n        ],\n        description: \"Merge two or more configurations using 'webpack-merge'.\",\n      },\n      // Complex configs\n      {\n        name: \"env\",\n        type: (value, previous = {}) => {\n          // for https://github.com/webpack/webpack-cli/issues/2642\n          if (value.endsWith(\"=\")) {\n            value.concat('\"\"');\n          }\n\n          // This ensures we're only splitting by the first `=`\n          const [allKeys, val] = value.split(/=(.+)/, 2);\n          const splitKeys = allKeys.split(/\\.(?!$)/);\n\n          let prevRef = previous;\n\n          splitKeys.forEach((someKey, index) => {\n            if (!prevRef[someKey]) {\n              prevRef[someKey] = {};\n            }\n\n            if (typeof prevRef[someKey] === \"string\") {\n              prevRef[someKey] = {};\n            }\n\n            if (index === splitKeys.length - 1) {\n              if (typeof val === \"string\") {\n                prevRef[someKey] = val;\n              } else {\n                prevRef[someKey] = true;\n              }\n            }\n\n            prevRef = prevRef[someKey];\n          });\n\n          return previous;\n        },\n        multiple: true,\n        description: \"Environment passed to the configuration when it is a function.\",\n      },\n      {\n        name: \"node-env\",\n        configs: [\n          {\n            type: \"string\",\n          },\n        ],\n        multiple: false,\n        description: \"Sets process.env.NODE_ENV to the specified value.\",\n      },\n\n      // Adding more plugins\n      {\n        name: \"hot\",\n        alias: \"h\",\n        configs: [\n          {\n            type: \"string\",\n          },\n          {\n            type: \"boolean\",\n          },\n        ],\n        negative: true,\n        description: \"Enables Hot Module Replacement\",\n        negatedDescription: \"Disables Hot Module Replacement.\",\n      },\n      {\n        name: \"analyze\",\n        configs: [\n          {\n            type: \"enum\",\n            values: [true],\n          },\n        ],\n        multiple: false,\n        description: \"It invokes webpack-bundle-analyzer plugin to get bundle information.\",\n      },\n      {\n        name: \"progress\",\n        configs: [\n          {\n            type: \"string\",\n          },\n          {\n            type: \"enum\",\n            values: [true],\n          },\n        ],\n        description: \"Print compilation progress during build.\",\n      },\n      {\n        name: \"prefetch\",\n        configs: [\n          {\n            type: \"string\",\n          },\n        ],\n        description: \"Prefetch this request.\",\n      },\n\n      // Output options\n      {\n        name: \"json\",\n        configs: [\n          {\n            type: \"string\",\n          },\n          {\n            type: \"enum\",\n            values: [true],\n          },\n        ],\n        alias: \"j\",\n        description: \"Prints result as JSON or store it in a file.\",\n      },\n\n      // For webpack@4\n      {\n        name: \"entry\",\n        configs: [\n          {\n            type: \"string\",\n          },\n        ],\n        multiple: true,\n        description: \"The entry point(s) of your application e.g. ./src/main.js.\",\n      },\n      {\n        name: \"output-path\",\n        alias: \"o\",\n        configs: [\n          {\n            type: \"string\",\n          },\n        ],\n        description: \"Output location of the file generated by webpack e.g. ./dist/.\",\n      },\n      {\n        name: \"target\",\n        alias: \"t\",\n        configs: [\n          {\n            type: \"string\",\n          },\n        ],\n        multiple: this.webpack.cli !== undefined,\n        description: \"Sets the build target e.g. node.\",\n      },\n      {\n        name: \"devtool\",\n        configs: [\n          {\n            type: \"string\",\n          },\n          {\n            type: \"enum\",\n            values: [false],\n          },\n        ],\n        negative: true,\n        alias: \"d\",\n        description: \"Determine source maps to use.\",\n        negatedDescription: \"Do not generate source maps.\",\n      },\n      {\n        name: \"mode\",\n        configs: [\n          {\n            type: \"string\",\n          },\n        ],\n        description: \"Defines the mode to pass to webpack.\",\n      },\n      {\n        name: \"name\",\n        configs: [\n          {\n            type: \"string\",\n          },\n        ],\n        description: \"Name of the configuration. Used when loading multiple configurations.\",\n      },\n      {\n        name: \"stats\",\n        configs: [\n          {\n            type: \"string\",\n          },\n          {\n            type: \"boolean\",\n          },\n        ],\n        negative: true,\n        description: \"It instructs webpack on how to treat the stats e.g. verbose.\",\n        negatedDescription: \"Disable stats output.\",\n      },\n      {\n        name: \"watch\",\n        configs: [\n          {\n            type: \"boolean\",\n          },\n        ],\n        negative: true,\n        alias: \"w\",\n        description: \"Watch for files changes.\",\n        negatedDescription: \"Do not watch for file changes.\",\n      },\n      {\n        name: \"watch-options-stdin\",\n        configs: [\n          {\n            type: \"boolean\",\n          },\n        ],\n        negative: true,\n        description: \"Stop watching when stdin stream has ended.\",\n        negatedDescription: \"Do not stop watching when stdin stream has ended.\",\n      },\n    ];\n\n    // Extract all the flags being exported from core.\n    // A list of cli flags generated by core can be found here https://github.com/webpack/webpack/blob/master/test/__snapshots__/Cli.test.js.snap\n    const coreFlags = this.webpack.cli\n      ? Object.entries(this.webpack.cli.getArguments()).map(([flag, meta]) => {\n          const inBuiltIn = builtInFlags.find((builtInFlag) => builtInFlag.name === flag);\n\n          if (inBuiltIn) {\n            return {\n              ...meta,\n              name: flag,\n              group: \"core\",\n              ...inBuiltIn,\n              configs: meta.configs || [],\n            };\n          }\n\n          return { ...meta, name: flag, group: \"core\" };\n        })\n      : [];\n\n    const options = []\n      .concat(\n        builtInFlags.filter(\n          (builtInFlag) => !coreFlags.find((coreFlag) => builtInFlag.name === coreFlag.name),\n        ),\n      )\n      .concat(coreFlags)\n      .map((option) => {\n        option.helpLevel = minimumHelpFlags.includes(option.name) ? \"minimum\" : \"verbose\";\n\n        return option;\n      });\n\n    this.builtInOptionsCache = options;\n\n    return options;\n  }\n\n  async loadWebpack(handleError = true) {\n    return this.tryRequireThenImport(WEBPACK_PACKAGE, handleError);\n  }\n\n  async run(args, parseOptions) {\n    // Built-in internal commands\n    const buildCommandOptions = {\n      name: \"build [entries...]\",\n      alias: [\"bundle\", \"b\"],\n      description: \"Run webpack (default command, can be omitted).\",\n      usage: \"[entries...] [options]\",\n      dependencies: [WEBPACK_PACKAGE],\n    };\n    const watchCommandOptions = {\n      name: \"watch [entries...]\",\n      alias: \"w\",\n      description: \"Run webpack and watch for files changes.\",\n      usage: \"[entries...] [options]\",\n      dependencies: [WEBPACK_PACKAGE],\n    };\n    const versionCommandOptions = {\n      name: \"version [commands...]\",\n      alias: \"v\",\n      description:\n        \"Output the version number of 'webpack', 'webpack-cli' and 'webpack-dev-server' and commands.\",\n    };\n    const helpCommandOptions = {\n      name: \"help [command] [option]\",\n      alias: \"h\",\n      description: \"Display help for commands and options.\",\n    };\n    // Built-in external commands\n    const externalBuiltInCommandsInfo = [\n      {\n        name: \"serve [entries...]\",\n        alias: [\"server\", \"s\"],\n        pkg: \"@webpack-cli/serve\",\n      },\n      {\n        name: \"info\",\n        alias: \"i\",\n        pkg: \"@webpack-cli/info\",\n      },\n      {\n        name: \"init\",\n        alias: [\"create\", \"new\", \"c\", \"n\"],\n        pkg: \"@webpack-cli/generators\",\n      },\n      {\n        name: \"loader\",\n        alias: \"l\",\n        pkg: \"@webpack-cli/generators\",\n      },\n      {\n        name: \"plugin\",\n        alias: \"p\",\n        pkg: \"@webpack-cli/generators\",\n      },\n      {\n        name: \"migrate\",\n        alias: \"m\",\n        pkg: \"@webpack-cli/migrate\",\n      },\n      {\n        name: \"configtest [config-path]\",\n        alias: \"t\",\n        pkg: \"@webpack-cli/configtest\",\n      },\n    ];\n\n    const knownCommands = [\n      buildCommandOptions,\n      watchCommandOptions,\n      versionCommandOptions,\n      helpCommandOptions,\n      ...externalBuiltInCommandsInfo,\n    ];\n    const getCommandName = (name) => name.split(\" \")[0];\n    const isKnownCommand = (name) =>\n      knownCommands.find(\n        (command) =>\n          getCommandName(command.name) === name ||\n          (Array.isArray(command.alias) ? command.alias.includes(name) : command.alias === name),\n      );\n    const isCommand = (input, commandOptions) => {\n      const longName = getCommandName(commandOptions.name);\n\n      if (input === longName) {\n        return true;\n      }\n\n      if (commandOptions.alias) {\n        if (Array.isArray(commandOptions.alias)) {\n          return commandOptions.alias.includes(input);\n        } else {\n          return commandOptions.alias === input;\n        }\n      }\n\n      return false;\n    };\n    const findCommandByName = (name) =>\n      this.program.commands.find(\n        (command) => name === command.name() || command.aliases().includes(name),\n      );\n    const isOption = (value) => value.startsWith(\"-\");\n    const isGlobalOption = (value) =>\n      value === \"--color\" ||\n      value === \"--no-color\" ||\n      value === \"-v\" ||\n      value === \"--version\" ||\n      value === \"-h\" ||\n      value === \"--help\";\n\n    const loadCommandByName = async (commandName, allowToInstall = false) => {\n      const isBuildCommandUsed = isCommand(commandName, buildCommandOptions);\n      const isWatchCommandUsed = isCommand(commandName, watchCommandOptions);\n\n      if (isBuildCommandUsed || isWatchCommandUsed) {\n        await this.makeCommand(\n          isBuildCommandUsed ? buildCommandOptions : watchCommandOptions,\n          async () => {\n            this.webpack = await this.loadWebpack();\n\n            return isWatchCommandUsed\n              ? this.getBuiltInOptions().filter((option) => option.name !== \"watch\")\n              : this.getBuiltInOptions();\n          },\n          async (entries, options) => {\n            if (entries.length > 0) {\n              options.entry = [...entries, ...(options.entry || [])];\n            }\n\n            await this.runWebpack(options, isWatchCommandUsed);\n          },\n        );\n      } else if (isCommand(commandName, helpCommandOptions)) {\n        // Stub for the `help` command\n        this.makeCommand(helpCommandOptions, [], () => {});\n      } else if (isCommand(commandName, versionCommandOptions)) {\n        // Stub for the `version` command\n        this.makeCommand(versionCommandOptions, [], () => {});\n      } else {\n        const builtInExternalCommandInfo = externalBuiltInCommandsInfo.find(\n          (externalBuiltInCommandInfo) =>\n            getCommandName(externalBuiltInCommandInfo.name) === commandName ||\n            (Array.isArray(externalBuiltInCommandInfo.alias)\n              ? externalBuiltInCommandInfo.alias.includes(commandName)\n              : externalBuiltInCommandInfo.alias === commandName),\n        );\n\n        let pkg;\n\n        if (builtInExternalCommandInfo) {\n          ({ pkg } = builtInExternalCommandInfo);\n        } else {\n          pkg = commandName;\n        }\n\n        if (pkg !== \"webpack-cli\" && !this.checkPackageExists(pkg)) {\n          if (!allowToInstall) {\n            return;\n          }\n\n          pkg = await this.doInstall(pkg, {\n            preMessage: () => {\n              this.logger.error(\n                `For using this command you need to install: '${this.colors.green(pkg)}' package.`,\n              );\n            },\n          });\n        }\n\n        let loadedCommand;\n\n        try {\n          loadedCommand = await this.tryRequireThenImport(pkg, false);\n        } catch (error) {\n          // Ignore, command is not installed\n\n          return;\n        }\n\n        let command;\n\n        try {\n          command = new loadedCommand();\n\n          await command.apply(this);\n        } catch (error) {\n          this.logger.error(`Unable to load '${pkg}' command`);\n          this.logger.error(error);\n          process.exit(2);\n        }\n      }\n    };\n\n    // Register own exit\n    this.program.exitOverride(async (error) => {\n      if (error.exitCode === 0) {\n        process.exit(0);\n      }\n\n      if (error.code === \"executeSubCommandAsync\") {\n        process.exit(2);\n      }\n\n      if (error.code === \"commander.help\") {\n        process.exit(0);\n      }\n\n      if (error.code === \"commander.unknownOption\") {\n        let name = error.message.match(/'(.+)'/);\n\n        if (name) {\n          name = name[1].substr(2);\n\n          if (name.includes(\"=\")) {\n            name = name.split(\"=\")[0];\n          }\n\n          const { operands } = this.program.parseOptions(this.program.args);\n          const operand =\n            typeof operands[0] !== \"undefined\"\n              ? operands[0]\n              : getCommandName(buildCommandOptions.name);\n\n          if (operand) {\n            const command = findCommandByName(operand);\n\n            if (!command) {\n              this.logger.error(`Can't find and load command '${operand}'`);\n              this.logger.error(\"Run 'webpack --help' to see available commands and options\");\n              process.exit(2);\n            }\n\n            const levenshtein = require(\"fastest-levenshtein\");\n\n            command.options.forEach((option) => {\n              if (!option.hidden && levenshtein.distance(name, option.long.slice(2)) < 3) {\n                this.logger.error(`Did you mean '--${option.name()}'?`);\n              }\n            });\n          }\n        }\n      }\n\n      // Codes:\n      // - commander.unknownCommand\n      // - commander.missingArgument\n      // - commander.missingMandatoryOptionValue\n      // - commander.optionMissingArgument\n\n      this.logger.error(\"Run 'webpack --help' to see available commands and options\");\n      process.exit(2);\n    });\n\n    // Default `--color` and `--no-color` options\n    const cli = this;\n    this.program.option(\"--color\", \"Enable colors on console.\");\n    this.program.on(\"option:color\", function () {\n      const { color } = this.opts();\n\n      cli.isColorSupportChanged = color;\n      cli.colors = cli.createColors(color);\n    });\n    this.program.option(\"--no-color\", \"Disable colors on console.\");\n    this.program.on(\"option:no-color\", function () {\n      const { color } = this.opts();\n\n      cli.isColorSupportChanged = color;\n      cli.colors = cli.createColors(color);\n    });\n\n    // Make `-v, --version` options\n    // Make `version|v [commands...]` command\n    const outputVersion = async (options) => {\n      // Filter `bundle`, `watch`, `version` and `help` commands\n      const possibleCommandNames = options.filter(\n        (option) =>\n          !isCommand(option, buildCommandOptions) &&\n          !isCommand(option, watchCommandOptions) &&\n          !isCommand(option, versionCommandOptions) &&\n          !isCommand(option, helpCommandOptions),\n      );\n\n      possibleCommandNames.forEach((possibleCommandName) => {\n        if (!isOption(possibleCommandName)) {\n          return;\n        }\n\n        this.logger.error(`Unknown option '${possibleCommandName}'`);\n        this.logger.error(\"Run 'webpack --help' to see available commands and options\");\n        process.exit(2);\n      });\n\n      if (possibleCommandNames.length > 0) {\n        await Promise.all(\n          possibleCommandNames.map((possibleCommand) => loadCommandByName(possibleCommand)),\n        );\n\n        for (const possibleCommandName of possibleCommandNames) {\n          const foundCommand = findCommandByName(possibleCommandName);\n\n          if (!foundCommand) {\n            this.logger.error(`Unknown command '${possibleCommandName}'`);\n            this.logger.error(\"Run 'webpack --help' to see available commands and options\");\n            process.exit(2);\n          }\n\n          try {\n            const { name, version } = this.loadJSONFile(`${foundCommand.pkg}/package.json`);\n\n            this.logger.raw(`${name} ${version}`);\n          } catch (e) {\n            this.logger.error(`Error: External package '${foundCommand.pkg}' not found`);\n            process.exit(2);\n          }\n        }\n      }\n\n      let webpack;\n\n      try {\n        webpack = await this.loadWebpack(false);\n      } catch (_error) {\n        // Nothing\n      }\n\n      this.logger.raw(`webpack: ${webpack ? webpack.version : \"not installed\"}`);\n\n      const pkgJSON = this.loadJSONFile(\"../package.json\");\n\n      this.logger.raw(`webpack-cli: ${pkgJSON.version}`);\n\n      let devServer;\n\n      try {\n        devServer = await this.loadJSONFile(\"webpack-dev-server/package.json\", false);\n      } catch (_error) {\n        // Nothing\n      }\n\n      this.logger.raw(`webpack-dev-server ${devServer ? devServer.version : \"not installed\"}`);\n\n      process.exit(0);\n    };\n    this.program.option(\n      \"-v, --version\",\n      \"Output the version number of 'webpack', 'webpack-cli' and 'webpack-dev-server' and commands.\",\n    );\n\n    const outputHelp = async (options, isVerbose, isHelpCommandSyntax, program) => {\n      const { bold } = this.colors;\n      const outputIncorrectUsageOfHelp = () => {\n        this.logger.error(\"Incorrect use of help\");\n        this.logger.error(\n          \"Please use: 'webpack help [command] [option]' | 'webpack [command] --help'\",\n        );\n        this.logger.error(\"Run 'webpack --help' to see available commands and options\");\n        process.exit(2);\n      };\n\n      const isGlobalHelp = options.length === 0;\n      const isCommandHelp = options.length === 1 && !isOption(options[0]);\n\n      if (isGlobalHelp || isCommandHelp) {\n        program.configureHelp({\n          sortSubcommands: true,\n          // Support multiple aliases\n          commandUsage: (command) => {\n            let parentCmdNames = \"\";\n\n            for (let parentCmd = command.parent; parentCmd; parentCmd = parentCmd.parent) {\n              parentCmdNames = `${parentCmd.name()} ${parentCmdNames}`;\n            }\n\n            if (isGlobalHelp) {\n              return `${parentCmdNames}${command.usage()}\\n${bold(\n                \"Alternative usage to run commands:\",\n              )} ${parentCmdNames}[command] [options]`;\n            }\n\n            return `${parentCmdNames}${command.name()}|${command\n              .aliases()\n              .join(\"|\")} ${command.usage()}`;\n          },\n          // Support multiple aliases\n          subcommandTerm: (command) => {\n            const humanReadableArgumentName = (argument) => {\n              const nameOutput = argument.name + (argument.variadic === true ? \"...\" : \"\");\n\n              return argument.required ? \"<\" + nameOutput + \">\" : \"[\" + nameOutput + \"]\";\n            };\n            const args = command._args.map((arg) => humanReadableArgumentName(arg)).join(\" \");\n\n            return `${command.name()}|${command.aliases().join(\"|\")}${args ? ` ${args}` : \"\"}${\n              command.options.length > 0 ? \" [options]\" : \"\"\n            }`;\n          },\n          visibleOptions: function visibleOptions(command) {\n            return command.options.filter((option) => {\n              if (option.hidden) {\n                return false;\n              }\n\n              switch (option.helpLevel) {\n                case \"verbose\":\n                  return isVerbose;\n                case \"minimum\":\n                default:\n                  return true;\n              }\n            });\n          },\n          padWidth(command, helper) {\n            return Math.max(\n              helper.longestArgumentTermLength(command, helper),\n              helper.longestOptionTermLength(command, helper),\n              // For global options\n              helper.longestOptionTermLength(program, helper),\n              helper.longestSubcommandTermLength(isGlobalHelp ? program : command, helper),\n            );\n          },\n          formatHelp: (command, helper) => {\n            const termWidth = helper.padWidth(command, helper);\n            const helpWidth = helper.helpWidth || process.env.WEBPACK_CLI_HELP_WIDTH || 80;\n            const itemIndentWidth = 2;\n            const itemSeparatorWidth = 2; // between term and description\n\n            const formatItem = (term, description) => {\n              if (description) {\n                const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n\n                return helper.wrap(\n                  fullText,\n                  helpWidth - itemIndentWidth,\n                  termWidth + itemSeparatorWidth,\n                );\n              }\n\n              return term;\n            };\n\n            const formatList = (textArray) =>\n              textArray.join(\"\\n\").replace(/^/gm, \" \".repeat(itemIndentWidth));\n\n            // Usage\n            let output = [`${bold(\"Usage:\")} ${helper.commandUsage(command)}`, \"\"];\n\n            // Description\n            const commandDescription = isGlobalHelp\n              ? \"The build tool for modern web applications.\"\n              : helper.commandDescription(command);\n\n            if (commandDescription.length > 0) {\n              output = output.concat([commandDescription, \"\"]);\n            }\n\n            // Arguments\n            const argumentList = helper\n              .visibleArguments(command)\n              .map((argument) => formatItem(argument.term, argument.description));\n\n            if (argumentList.length > 0) {\n              output = output.concat([bold(\"Arguments:\"), formatList(argumentList), \"\"]);\n            }\n\n            // Options\n            const optionList = helper\n              .visibleOptions(command)\n              .map((option) =>\n                formatItem(helper.optionTerm(option), helper.optionDescription(option)),\n              );\n\n            if (optionList.length > 0) {\n              output = output.concat([bold(\"Options:\"), formatList(optionList), \"\"]);\n            }\n\n            // Global options\n            const globalOptionList = program.options.map((option) =>\n              formatItem(helper.optionTerm(option), helper.optionDescription(option)),\n            );\n\n            if (globalOptionList.length > 0) {\n              output = output.concat([bold(\"Global options:\"), formatList(globalOptionList), \"\"]);\n            }\n\n            // Commands\n            const commandList = helper\n              .visibleCommands(isGlobalHelp ? program : command)\n              .map((command) =>\n                formatItem(helper.subcommandTerm(command), helper.subcommandDescription(command)),\n              );\n\n            if (commandList.length > 0) {\n              output = output.concat([bold(\"Commands:\"), formatList(commandList), \"\"]);\n            }\n\n            return output.join(\"\\n\");\n          },\n        });\n\n        if (isGlobalHelp) {\n          await Promise.all(\n            knownCommands.map((knownCommand) => {\n              return loadCommandByName(getCommandName(knownCommand.name));\n            }),\n          );\n\n          const buildCommand = findCommandByName(getCommandName(buildCommandOptions.name));\n\n          this.logger.raw(buildCommand.helpInformation());\n        } else {\n          const name = options[0];\n\n          await loadCommandByName(name);\n\n          const command = findCommandByName(name);\n\n          if (!command) {\n            const builtInCommandUsed = externalBuiltInCommandsInfo.find(\n              (command) => command.name.includes(name) || name === command.alias,\n            );\n            if (typeof builtInCommandUsed !== \"undefined\") {\n              this.logger.error(\n                `For using '${name}' command you need to install '${builtInCommandUsed.pkg}' package.`,\n              );\n            } else {\n              this.logger.error(`Can't find and load command '${name}'`);\n              this.logger.error(\"Run 'webpack --help' to see available commands and options.\");\n            }\n            process.exit(2);\n          }\n\n          this.logger.raw(command.helpInformation());\n        }\n      } else if (isHelpCommandSyntax) {\n        let isCommandSpecified = false;\n        let commandName = getCommandName(buildCommandOptions.name);\n        let optionName;\n\n        if (options.length === 1) {\n          optionName = options[0];\n        } else if (options.length === 2) {\n          isCommandSpecified = true;\n          commandName = options[0];\n          optionName = options[1];\n\n          if (isOption(commandName)) {\n            outputIncorrectUsageOfHelp();\n          }\n        } else {\n          outputIncorrectUsageOfHelp();\n        }\n\n        await loadCommandByName(commandName);\n\n        const command = isGlobalOption(optionName) ? program : findCommandByName(commandName);\n\n        if (!command) {\n          this.logger.error(`Can't find and load command '${commandName}'`);\n          this.logger.error(\"Run 'webpack --help' to see available commands and options\");\n          process.exit(2);\n        }\n\n        const option = command.options.find(\n          (option) => option.short === optionName || option.long === optionName,\n        );\n\n        if (!option) {\n          this.logger.error(`Unknown option '${optionName}'`);\n          this.logger.error(\"Run 'webpack --help' to see available commands and options\");\n          process.exit(2);\n        }\n\n        const nameOutput =\n          option.flags.replace(/^.+[[<]/, \"\").replace(/(\\.\\.\\.)?[\\]>].*$/, \"\") +\n          (option.variadic === true ? \"...\" : \"\");\n        const value = option.required\n          ? \"<\" + nameOutput + \">\"\n          : option.optional\n          ? \"[\" + nameOutput + \"]\"\n          : \"\";\n\n        this.logger.raw(\n          `${bold(\"Usage\")}: webpack${isCommandSpecified ? ` ${commandName}` : \"\"} ${option.long}${\n            value ? ` ${value}` : \"\"\n          }`,\n        );\n\n        if (option.short) {\n          this.logger.raw(\n            `${bold(\"Short:\")} webpack${isCommandSpecified ? ` ${commandName}` : \"\"} ${\n              option.short\n            }${value ? ` ${value}` : \"\"}`,\n          );\n        }\n\n        if (option.description) {\n          this.logger.raw(`${bold(\"Description:\")} ${option.description}`);\n        }\n\n        if (!option.negate && option.defaultValue) {\n          this.logger.raw(`${bold(\"Default value:\")} ${JSON.stringify(option.defaultValue)}`);\n        }\n\n        const flag = this.getBuiltInOptions().find((flag) => option.long === `--${flag.name}`);\n\n        if (flag && flag.configs) {\n          const possibleValues = flag.configs.reduce((accumulator, currentValue) => {\n            if (currentValue.values) {\n              return accumulator.concat(currentValue.values);\n            } else {\n              return accumulator;\n            }\n          }, []);\n\n          if (possibleValues.length > 0) {\n            this.logger.raw(\n              `${bold(\"Possible values:\")} ${JSON.stringify(possibleValues.join(\" | \"))}`,\n            );\n          }\n        }\n\n        this.logger.raw(\"\");\n\n        // TODO implement this after refactor cli arguments\n        // logger.raw('Documentation: https://webpack.js.org/option/name/');\n      } else {\n        outputIncorrectUsageOfHelp();\n      }\n\n      this.logger.raw(\n        \"To see list of all supported commands and options run 'webpack --help=verbose'.\\n\",\n      );\n      this.logger.raw(`${bold(\"Webpack documentation:\")} https://webpack.js.org/.`);\n      this.logger.raw(`${bold(\"CLI documentation:\")} https://webpack.js.org/api/cli/.`);\n      this.logger.raw(`${bold(\"Made with  by the webpack team\")}.`);\n      process.exit(0);\n    };\n    this.program.helpOption(false);\n    this.program.addHelpCommand(false);\n    this.program.option(\"-h, --help [verbose]\", \"Display help for commands and options.\");\n\n    let isInternalActionCalled = false;\n\n    // Default action\n    this.program.usage(\"[options]\");\n    this.program.allowUnknownOption(true);\n    this.program.action(async (options, program) => {\n      if (!isInternalActionCalled) {\n        isInternalActionCalled = true;\n      } else {\n        this.logger.error(\"No commands found to run\");\n        process.exit(2);\n      }\n\n      // Command and options\n      const { operands, unknown } = this.program.parseOptions(program.args);\n      const defaultCommandToRun = getCommandName(buildCommandOptions.name);\n      const hasOperand = typeof operands[0] !== \"undefined\";\n      const operand = hasOperand ? operands[0] : defaultCommandToRun;\n      const isHelpOption = typeof options.help !== \"undefined\";\n      const isHelpCommandSyntax = isCommand(operand, helpCommandOptions);\n\n      if (isHelpOption || isHelpCommandSyntax) {\n        let isVerbose = false;\n\n        if (isHelpOption) {\n          if (typeof options.help === \"string\") {\n            if (options.help !== \"verbose\") {\n              this.logger.error(\"Unknown value for '--help' option, please use '--help=verbose'\");\n              process.exit(2);\n            }\n\n            isVerbose = true;\n          }\n        }\n\n        this.program.forHelp = true;\n\n        const optionsForHelp = []\n          .concat(isHelpOption && hasOperand ? [operand] : [])\n          // Syntax `webpack help [command]`\n          .concat(operands.slice(1))\n          // Syntax `webpack help [option]`\n          .concat(unknown)\n          .concat(\n            isHelpCommandSyntax && typeof options.color !== \"undefined\"\n              ? [options.color ? \"--color\" : \"--no-color\"]\n              : [],\n          )\n          .concat(\n            isHelpCommandSyntax && typeof options.version !== \"undefined\" ? [\"--version\"] : [],\n          );\n\n        await outputHelp(optionsForHelp, isVerbose, isHelpCommandSyntax, program);\n      }\n\n      const isVersionOption = typeof options.version !== \"undefined\";\n      const isVersionCommandSyntax = isCommand(operand, versionCommandOptions);\n\n      if (isVersionOption || isVersionCommandSyntax) {\n        const optionsForVersion = []\n          .concat(isVersionOption ? [operand] : [])\n          .concat(operands.slice(1))\n          .concat(unknown);\n\n        await outputVersion(optionsForVersion, program);\n      }\n\n      let commandToRun = operand;\n      let commandOperands = operands.slice(1);\n\n      if (isKnownCommand(commandToRun)) {\n        await loadCommandByName(commandToRun, true);\n      } else {\n        const isEntrySyntax = fs.existsSync(operand);\n\n        if (isEntrySyntax) {\n          commandToRun = defaultCommandToRun;\n          commandOperands = operands;\n\n          await loadCommandByName(commandToRun);\n        } else {\n          this.logger.error(`Unknown command or entry '${operand}'`);\n\n          const levenshtein = require(\"fastest-levenshtein\");\n          const found = knownCommands.find(\n            (commandOptions) =>\n              levenshtein.distance(operand, getCommandName(commandOptions.name)) < 3,\n          );\n\n          if (found) {\n            this.logger.error(\n              `Did you mean '${getCommandName(found.name)}' (alias '${\n                Array.isArray(found.alias) ? found.alias.join(\", \") : found.alias\n              }')?`,\n            );\n          }\n\n          this.logger.error(\"Run 'webpack --help' to see available commands and options\");\n          process.exit(2);\n        }\n      }\n\n      await this.program.parseAsync([commandToRun, ...commandOperands, ...unknown], {\n        from: \"user\",\n      });\n    });\n\n    await this.program.parseAsync(args, parseOptions);\n  }\n\n  async loadConfig(options) {\n    const interpret = require(\"interpret\");\n    const loadConfigByPath = async (configPath, argv = {}) => {\n      const ext = path.extname(configPath);\n      const interpreted = Object.keys(interpret.jsVariants).find((variant) => variant === ext);\n\n      if (interpreted) {\n        const rechoir = require(\"rechoir\");\n\n        try {\n          rechoir.prepare(interpret.extensions, configPath);\n        } catch (error) {\n          if (error.failures) {\n            this.logger.error(`Unable load '${configPath}'`);\n            this.logger.error(error.message);\n            error.failures.forEach((failure) => {\n              this.logger.error(failure.error.message);\n            });\n            this.logger.error(\"Please install one of them\");\n            process.exit(2);\n          }\n\n          this.logger.error(error);\n          process.exit(2);\n        }\n      }\n\n      let options;\n\n      try {\n        options = await this.tryRequireThenImport(configPath, false);\n      } catch (error) {\n        this.logger.error(`Failed to load '${configPath}' config`);\n\n        if (this.isValidationError(error)) {\n          this.logger.error(error.message);\n        } else {\n          this.logger.error(error);\n        }\n\n        process.exit(2);\n      }\n\n      if (Array.isArray(options)) {\n        await Promise.all(\n          options.map(async (_, i) => {\n            if (typeof options[i].then === \"function\") {\n              options[i] = await options[i];\n            }\n\n            // `Promise` may return `Function`\n            if (typeof options[i] === \"function\") {\n              // when config is a function, pass the env from args to the config function\n              options[i] = await options[i](argv.env, argv);\n            }\n          }),\n        );\n      } else {\n        if (typeof options.then === \"function\") {\n          options = await options;\n        }\n\n        // `Promise` may return `Function`\n        if (typeof options === \"function\") {\n          // when config is a function, pass the env from args to the config function\n          options = await options(argv.env, argv);\n        }\n      }\n\n      const isObject = (value) => typeof value === \"object\" && value !== null;\n\n      if (!isObject(options) && !Array.isArray(options)) {\n        this.logger.error(`Invalid configuration in '${configPath}'`);\n\n        process.exit(2);\n      }\n\n      return { options, path: configPath };\n    };\n\n    const config = { options: {}, path: new WeakMap() };\n\n    if (options.config && options.config.length > 0) {\n      const loadedConfigs = await Promise.all(\n        options.config.map((configPath) =>\n          loadConfigByPath(path.resolve(configPath), options.argv),\n        ),\n      );\n\n      config.options = [];\n\n      loadedConfigs.forEach((loadedConfig) => {\n        const isArray = Array.isArray(loadedConfig.options);\n\n        // TODO we should run webpack multiple times when the `--config` options have multiple values with `--merge`, need to solve for the next major release\n        if (config.options.length === 0) {\n          config.options = loadedConfig.options;\n        } else {\n          if (!Array.isArray(config.options)) {\n            config.options = [config.options];\n          }\n\n          if (isArray) {\n            loadedConfig.options.forEach((item) => {\n              config.options.push(item);\n            });\n          } else {\n            config.options.push(loadedConfig.options);\n          }\n        }\n\n        if (isArray) {\n          loadedConfig.options.forEach((options) => {\n            config.path.set(options, loadedConfig.path);\n          });\n        } else {\n          config.path.set(loadedConfig.options, loadedConfig.path);\n        }\n      });\n\n      config.options = config.options.length === 1 ? config.options[0] : config.options;\n    } else {\n      // Order defines the priority, in decreasing order\n      const defaultConfigFiles = [\n        \"webpack.config\",\n        \".webpack/webpack.config\",\n        \".webpack/webpackfile\",\n      ]\n        .map((filename) =>\n          // Since .cjs is not available on interpret side add it manually to default config extension list\n          [...Object.keys(interpret.extensions), \".cjs\"].map((ext) => ({\n            path: path.resolve(filename + ext),\n            ext: ext,\n            module: interpret.extensions[ext],\n          })),\n        )\n        .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n\n      let foundDefaultConfigFile;\n\n      for (const defaultConfigFile of defaultConfigFiles) {\n        if (!fs.existsSync(defaultConfigFile.path)) {\n          continue;\n        }\n\n        foundDefaultConfigFile = defaultConfigFile;\n        break;\n      }\n\n      if (foundDefaultConfigFile) {\n        const loadedConfig = await loadConfigByPath(foundDefaultConfigFile.path, options.argv);\n\n        config.options = loadedConfig.options;\n\n        if (Array.isArray(config.options)) {\n          config.options.forEach((item) => {\n            config.path.set(item, loadedConfig.path);\n          });\n        } else {\n          config.path.set(loadedConfig.options, loadedConfig.path);\n        }\n      }\n    }\n\n    if (options.configName) {\n      const notFoundConfigNames = [];\n\n      config.options = options.configName.map((configName) => {\n        let found;\n\n        if (Array.isArray(config.options)) {\n          found = config.options.find((options) => options.name === configName);\n        } else {\n          found = config.options.name === configName ? config.options : undefined;\n        }\n\n        if (!found) {\n          notFoundConfigNames.push(configName);\n        }\n\n        return found;\n      });\n\n      if (notFoundConfigNames.length > 0) {\n        this.logger.error(\n          notFoundConfigNames\n            .map((configName) => `Configuration with the name \"${configName}\" was not found.`)\n            .join(\" \"),\n        );\n        process.exit(2);\n      }\n    }\n\n    if (options.merge) {\n      const merge = await this.tryRequireThenImport(\"webpack-merge\");\n\n      // we can only merge when there are multiple configurations\n      // either by passing multiple configs by flags or passing a\n      // single config exporting an array\n      if (!Array.isArray(config.options) || config.options.length <= 1) {\n        this.logger.error(\"At least two configurations are required for merge.\");\n        process.exit(2);\n      }\n\n      const mergedConfigPaths = [];\n\n      config.options = config.options.reduce((accumulator, options) => {\n        const configPath = config.path.get(options);\n        const mergedOptions = merge(accumulator, options);\n\n        mergedConfigPaths.push(configPath);\n\n        return mergedOptions;\n      }, {});\n      config.path.set(config.options, mergedConfigPaths);\n    }\n\n    return config;\n  }\n\n  async buildConfig(config, options) {\n    const runFunctionOnEachConfig = (options, fn) => {\n      if (Array.isArray(options)) {\n        for (let item of options) {\n          item = fn(item);\n        }\n      } else {\n        options = fn(options);\n      }\n\n      return options;\n    };\n\n    if (options.analyze) {\n      if (!this.checkPackageExists(\"webpack-bundle-analyzer\")) {\n        await this.doInstall(\"webpack-bundle-analyzer\", {\n          preMessage: () => {\n            this.logger.error(\n              `It looks like ${this.colors.yellow(\"webpack-bundle-analyzer\")} is not installed.`,\n            );\n          },\n        });\n\n        this.logger.success(\n          `${this.colors.yellow(\"webpack-bundle-analyzer\")} was installed successfully.`,\n        );\n      }\n    }\n\n    if (typeof options.progress === \"string\" && options.progress !== \"profile\") {\n      this.logger.error(\n        `'${options.progress}' is an invalid value for the --progress option. Only 'profile' is allowed.`,\n      );\n      process.exit(2);\n    }\n\n    if (typeof options.hot === \"string\" && options.hot !== \"only\") {\n      this.logger.error(\n        `'${options.hot}' is an invalid value for the --hot option. Use 'only' instead.`,\n      );\n      process.exit(2);\n    }\n\n    const CLIPlugin = await this.tryRequireThenImport(\"./plugins/CLIPlugin\");\n\n    const internalBuildConfig = (item) => {\n      // Output warnings\n      if (\n        item.watch &&\n        options.argv &&\n        options.argv.env &&\n        (options.argv.env[\"WEBPACK_WATCH\"] || options.argv.env[\"WEBPACK_SERVE\"])\n      ) {\n        this.logger.warn(\n          `No need to use the '${\n            options.argv.env[\"WEBPACK_WATCH\"] ? \"watch\" : \"serve\"\n          }' command together with '{ watch: true }' configuration, it does not make sense.`,\n        );\n\n        if (options.argv.env[\"WEBPACK_SERVE\"]) {\n          item.watch = false;\n        }\n      }\n\n      // Apply options\n      if (this.webpack.cli) {\n        const args = this.getBuiltInOptions()\n          .filter((flag) => flag.group === \"core\")\n          .reduce((accumulator, flag) => {\n            accumulator[flag.name] = flag;\n\n            return accumulator;\n          }, {});\n\n        const values = Object.keys(options).reduce((accumulator, name) => {\n          if (name === \"argv\") {\n            return accumulator;\n          }\n\n          const kebabName = this.toKebabCase(name);\n\n          if (args[kebabName]) {\n            accumulator[kebabName] = options[name];\n          }\n\n          return accumulator;\n        }, {});\n\n        const problems = this.webpack.cli.processArguments(args, item, values);\n\n        if (problems) {\n          const groupBy = (xs, key) => {\n            return xs.reduce((rv, x) => {\n              (rv[x[key]] = rv[x[key]] || []).push(x);\n\n              return rv;\n            }, {});\n          };\n          const problemsByPath = groupBy(problems, \"path\");\n\n          for (const path in problemsByPath) {\n            const problems = problemsByPath[path];\n\n            problems.forEach((problem) => {\n              this.logger.error(\n                `${this.capitalizeFirstLetter(problem.type.replace(/-/g, \" \"))}${\n                  problem.value ? ` '${problem.value}'` : \"\"\n                } for the '--${problem.argument}' option${\n                  problem.index ? ` by index '${problem.index}'` : \"\"\n                }`,\n              );\n\n              if (problem.expected) {\n                this.logger.error(`Expected: '${problem.expected}'`);\n              }\n            });\n          }\n\n          process.exit(2);\n        }\n\n        // Setup default cache options\n        if (item.cache && item.cache.type === \"filesystem\") {\n          const configPath = config.path.get(item);\n\n          if (configPath) {\n            if (!item.cache.buildDependencies) {\n              item.cache.buildDependencies = {};\n            }\n\n            if (!item.cache.buildDependencies.defaultConfig) {\n              item.cache.buildDependencies.defaultConfig = [];\n            }\n\n            if (Array.isArray(configPath)) {\n              configPath.forEach((oneOfConfigPath) => {\n                item.cache.buildDependencies.defaultConfig.push(oneOfConfigPath);\n              });\n            } else {\n              item.cache.buildDependencies.defaultConfig.push(configPath);\n            }\n          }\n        }\n      }\n\n      // Setup legacy logic for webpack@4\n      // TODO respect `--entry-reset` in th next major release\n      // TODO drop in the next major release\n      if (options.entry) {\n        item.entry = options.entry;\n      }\n\n      if (options.outputPath) {\n        item.output = { ...item.output, ...{ path: path.resolve(options.outputPath) } };\n      }\n\n      if (options.target) {\n        item.target = options.target;\n      }\n\n      if (typeof options.devtool !== \"undefined\") {\n        item.devtool = options.devtool;\n      }\n\n      if (options.name) {\n        item.name = options.name;\n      }\n\n      if (typeof options.stats !== \"undefined\") {\n        item.stats = options.stats;\n      }\n\n      if (typeof options.watch !== \"undefined\") {\n        item.watch = options.watch;\n      }\n\n      if (typeof options.watchOptionsStdin !== \"undefined\") {\n        item.watchOptions = { ...item.watchOptions, ...{ stdin: options.watchOptionsStdin } };\n      }\n\n      if (options.mode) {\n        item.mode = options.mode;\n      }\n\n      // Respect `process.env.NODE_ENV`\n      if (\n        !item.mode &&\n        process.env &&\n        process.env.NODE_ENV &&\n        (process.env.NODE_ENV === \"development\" ||\n          process.env.NODE_ENV === \"production\" ||\n          process.env.NODE_ENV === \"none\")\n      ) {\n        item.mode = process.env.NODE_ENV;\n      }\n\n      // Setup stats\n      // TODO remove after drop webpack@4\n      const statsForWebpack4 = this.webpack.Stats && this.webpack.Stats.presetToOptions;\n\n      if (statsForWebpack4) {\n        if (typeof item.stats === \"undefined\") {\n          item.stats = {};\n        } else if (typeof item.stats === \"boolean\") {\n          item.stats = this.webpack.Stats.presetToOptions(item.stats);\n        } else if (\n          typeof item.stats === \"string\" &&\n          (item.stats === \"none\" ||\n            item.stats === \"verbose\" ||\n            item.stats === \"detailed\" ||\n            item.stats === \"normal\" ||\n            item.stats === \"minimal\" ||\n            item.stats === \"errors-only\" ||\n            item.stats === \"errors-warnings\")\n        ) {\n          item.stats = this.webpack.Stats.presetToOptions(item.stats);\n        }\n      } else {\n        if (typeof item.stats === \"undefined\") {\n          item.stats = { preset: \"normal\" };\n        } else if (typeof item.stats === \"boolean\") {\n          item.stats = item.stats ? { preset: \"normal\" } : { preset: \"none\" };\n        } else if (typeof item.stats === \"string\") {\n          item.stats = { preset: item.stats };\n        }\n      }\n\n      let colors;\n\n      // From arguments\n      if (typeof this.isColorSupportChanged !== \"undefined\") {\n        colors = Boolean(this.isColorSupportChanged);\n      }\n      // From stats\n      else if (typeof item.stats.colors !== \"undefined\") {\n        colors = item.stats.colors;\n      }\n      // Default\n      else {\n        colors = Boolean(this.colors.isColorSupported);\n      }\n\n      // TODO remove after drop webpack v4\n      if (typeof item.stats === \"object\" && item.stats !== null) {\n        item.stats.colors = colors;\n      }\n\n      // Apply CLI plugin\n      if (!item.plugins) {\n        item.plugins = [];\n      }\n\n      item.plugins.unshift(\n        new CLIPlugin({\n          configPath: config.path.get(item),\n          helpfulOutput: !options.json,\n          hot: options.hot,\n          progress: options.progress,\n          prefetch: options.prefetch,\n          analyze: options.analyze,\n        }),\n      );\n\n      return options;\n    };\n\n    runFunctionOnEachConfig(config.options, internalBuildConfig);\n\n    return config;\n  }\n\n  isValidationError(error) {\n    // https://github.com/webpack/webpack/blob/master/lib/index.js#L267\n    // https://github.com/webpack/webpack/blob/v4.44.2/lib/webpack.js#L90\n    const ValidationError =\n      this.webpack.ValidationError || this.webpack.WebpackOptionsValidationError;\n\n    return error instanceof ValidationError || error.name === \"ValidationError\";\n  }\n\n  async createCompiler(options, callback) {\n    if (typeof options.nodeEnv === \"string\") {\n      process.env.NODE_ENV = options.nodeEnv;\n    }\n\n    let config = await this.loadConfig(options);\n    config = await this.buildConfig(config, options);\n\n    let compiler;\n\n    try {\n      compiler = this.webpack(\n        config.options,\n        callback\n          ? (error, stats) => {\n              if (error && this.isValidationError(error)) {\n                this.logger.error(error.message);\n                process.exit(2);\n              }\n\n              callback(error, stats);\n            }\n          : callback,\n      );\n    } catch (error) {\n      if (this.isValidationError(error)) {\n        this.logger.error(error.message);\n      } else {\n        this.logger.error(error);\n      }\n\n      process.exit(2);\n    }\n\n    // TODO webpack@4 return Watching and MultiWatching instead Compiler and MultiCompiler, remove this after drop webpack@4\n    if (compiler && compiler.compiler) {\n      compiler = compiler.compiler;\n    }\n\n    return compiler;\n  }\n\n  needWatchStdin(compiler) {\n    if (compiler.compilers) {\n      return compiler.compilers.some(\n        (compiler) => compiler.options.watchOptions && compiler.options.watchOptions.stdin,\n      );\n    }\n\n    return compiler.options.watchOptions && compiler.options.watchOptions.stdin;\n  }\n\n  async runWebpack(options, isWatchCommand) {\n    // eslint-disable-next-line prefer-const\n    let compiler;\n    let createJsonStringifyStream;\n\n    if (options.json) {\n      const jsonExt = await this.tryRequireThenImport(\"@discoveryjs/json-ext\");\n\n      createJsonStringifyStream = jsonExt.stringifyStream;\n    }\n\n    const callback = (error, stats) => {\n      if (error) {\n        this.logger.error(error);\n        process.exit(2);\n      }\n\n      if (stats.hasErrors()) {\n        process.exitCode = 1;\n      }\n\n      if (!compiler) {\n        return;\n      }\n\n      const statsOptions = compiler.compilers\n        ? {\n            children: compiler.compilers.map((compiler) =>\n              compiler.options ? compiler.options.stats : undefined,\n            ),\n          }\n        : compiler.options\n        ? compiler.options.stats\n        : undefined;\n\n      // TODO webpack@4 doesn't support `{ children: [{ colors: true }, { colors: true }] }` for stats\n      const statsForWebpack4 = this.webpack.Stats && this.webpack.Stats.presetToOptions;\n\n      if (compiler.compilers && statsForWebpack4) {\n        statsOptions.colors = statsOptions.children.some((child) => child.colors);\n      }\n\n      if (options.json && createJsonStringifyStream) {\n        const handleWriteError = (error) => {\n          this.logger.error(error);\n          process.exit(2);\n        };\n\n        if (options.json === true) {\n          createJsonStringifyStream(stats.toJson(statsOptions))\n            .on(\"error\", handleWriteError)\n            .pipe(process.stdout)\n            .on(\"error\", handleWriteError)\n            .on(\"close\", () => process.stdout.write(\"\\n\"));\n        } else {\n          createJsonStringifyStream(stats.toJson(statsOptions))\n            .on(\"error\", handleWriteError)\n            .pipe(fs.createWriteStream(options.json))\n            .on(\"error\", handleWriteError)\n            // Use stderr to logging\n            .on(\"close\", () => {\n              process.stderr.write(\n                `[webpack-cli] ${this.colors.green(\n                  `stats are successfully stored as json to ${options.json}`,\n                )}\\n`,\n              );\n            });\n        }\n      } else {\n        const printedStats = stats.toString(statsOptions);\n\n        // Avoid extra empty line when `stats: 'none'`\n        if (printedStats) {\n          this.logger.raw(printedStats);\n        }\n      }\n    };\n\n    const env =\n      isWatchCommand || options.watch\n        ? { WEBPACK_WATCH: true, ...options.env }\n        : { WEBPACK_BUNDLE: true, WEBPACK_BUILD: true, ...options.env };\n\n    options.argv = { ...options, env };\n\n    if (isWatchCommand) {\n      options.watch = true;\n    }\n\n    compiler = await this.createCompiler(options, callback);\n\n    if (!compiler) {\n      return;\n    }\n\n    const isWatch = (compiler) =>\n      compiler.compilers\n        ? compiler.compilers.some((compiler) => compiler.options.watch)\n        : compiler.options.watch;\n\n    if (isWatch(compiler) && this.needWatchStdin(compiler)) {\n      process.stdin.on(\"end\", () => {\n        process.exit(0);\n      });\n      process.stdin.resume();\n    }\n  }\n}\n\nmodule.exports = WebpackCLI;\n","function dynamicImportLoader() {\n  let importESM;\n\n  try {\n    importESM = new Function(\"id\", \"return import(id);\");\n  } catch (e) {\n    importESM = null;\n  }\n\n  return importESM;\n}\n\nmodule.exports = dynamicImportLoader;\n"]}