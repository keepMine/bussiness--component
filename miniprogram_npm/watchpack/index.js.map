{"version":3,"sources":["watchpack.js","getWatcherManager.js","DirectoryWatcher.js","watchEventSource.js","reducePlan.js","LinkResolver.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,AJYA,AGTA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AGTA,ADGA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,AENA,ADGA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst getWatcherManager = require(\"./getWatcherManager\");\nconst LinkResolver = require(\"./LinkResolver\");\nconst EventEmitter = require(\"events\").EventEmitter;\nconst globToRegExp = require(\"glob-to-regexp\");\nconst watchEventSource = require(\"./watchEventSource\");\n\nconst EMPTY_ARRAY = [];\nconst EMPTY_OPTIONS = {};\n\nfunction addWatchersToSet(watchers, set) {\n\tfor (const ww of watchers) {\n\t\tconst w = ww.watcher;\n\t\tif (!set.has(w.directoryWatcher)) {\n\t\t\tset.add(w.directoryWatcher);\n\t\t}\n\t}\n}\n\nconst stringToRegexp = ignored => {\n\tconst source = globToRegExp(ignored, { globstar: true, extended: true })\n\t\t.source;\n\tconst matchingStart = source.slice(0, source.length - 1) + \"(?:$|\\\\/)\";\n\treturn matchingStart;\n};\n\nconst ignoredToFunction = ignored => {\n\tif (Array.isArray(ignored)) {\n\t\tconst regexp = new RegExp(ignored.map(i => stringToRegexp(i)).join(\"|\"));\n\t\treturn x => regexp.test(x.replace(/\\\\/g, \"/\"));\n\t} else if (typeof ignored === \"string\") {\n\t\tconst regexp = new RegExp(stringToRegexp(ignored));\n\t\treturn x => regexp.test(x.replace(/\\\\/g, \"/\"));\n\t} else if (ignored instanceof RegExp) {\n\t\treturn x => ignored.test(x.replace(/\\\\/g, \"/\"));\n\t} else if (ignored instanceof Function) {\n\t\treturn ignored;\n\t} else if (ignored) {\n\t\tthrow new Error(`Invalid option for 'ignored': ${ignored}`);\n\t} else {\n\t\treturn () => false;\n\t}\n};\n\nconst normalizeOptions = options => {\n\treturn {\n\t\tfollowSymlinks: !!options.followSymlinks,\n\t\tignored: ignoredToFunction(options.ignored),\n\t\tpoll: options.poll\n\t};\n};\n\nconst normalizeCache = new WeakMap();\nconst cachedNormalizeOptions = options => {\n\tconst cacheEntry = normalizeCache.get(options);\n\tif (cacheEntry !== undefined) return cacheEntry;\n\tconst normalized = normalizeOptions(options);\n\tnormalizeCache.set(options, normalized);\n\treturn normalized;\n};\n\nclass WatchpackFileWatcher {\n\tconstructor(watchpack, watcher, files) {\n\t\tthis.files = Array.isArray(files) ? files : [files];\n\t\tthis.watcher = watcher;\n\t\twatcher.on(\"initial-missing\", type => {\n\t\t\tfor (const file of this.files) {\n\t\t\t\tif (!watchpack._missing.has(file))\n\t\t\t\t\twatchpack._onRemove(file, file, type);\n\t\t\t}\n\t\t});\n\t\twatcher.on(\"change\", (mtime, type) => {\n\t\t\tfor (const file of this.files) {\n\t\t\t\twatchpack._onChange(file, mtime, file, type);\n\t\t\t}\n\t\t});\n\t\twatcher.on(\"remove\", type => {\n\t\t\tfor (const file of this.files) {\n\t\t\t\twatchpack._onRemove(file, file, type);\n\t\t\t}\n\t\t});\n\t}\n\n\tupdate(files) {\n\t\tif (!Array.isArray(files)) {\n\t\t\tif (this.files.length !== 1) {\n\t\t\t\tthis.files = [files];\n\t\t\t} else if (this.files[0] !== files) {\n\t\t\t\tthis.files[0] = files;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.files = files;\n\t\t}\n\t}\n\n\tclose() {\n\t\tthis.watcher.close();\n\t}\n}\n\nclass WatchpackDirectoryWatcher {\n\tconstructor(watchpack, watcher, directories) {\n\t\tthis.directories = Array.isArray(directories) ? directories : [directories];\n\t\tthis.watcher = watcher;\n\t\twatcher.on(\"initial-missing\", type => {\n\t\t\tfor (const item of this.directories) {\n\t\t\t\twatchpack._onRemove(item, item, type);\n\t\t\t}\n\t\t});\n\t\twatcher.on(\"change\", (file, mtime, type) => {\n\t\t\tfor (const item of this.directories) {\n\t\t\t\twatchpack._onChange(item, mtime, file, type);\n\t\t\t}\n\t\t});\n\t\twatcher.on(\"remove\", type => {\n\t\t\tfor (const item of this.directories) {\n\t\t\t\twatchpack._onRemove(item, item, type);\n\t\t\t}\n\t\t});\n\t}\n\n\tupdate(directories) {\n\t\tif (!Array.isArray(directories)) {\n\t\t\tif (this.directories.length !== 1) {\n\t\t\t\tthis.directories = [directories];\n\t\t\t} else if (this.directories[0] !== directories) {\n\t\t\t\tthis.directories[0] = directories;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.directories = directories;\n\t\t}\n\t}\n\n\tclose() {\n\t\tthis.watcher.close();\n\t}\n}\n\nclass Watchpack extends EventEmitter {\n\tconstructor(options) {\n\t\tsuper();\n\t\tif (!options) options = EMPTY_OPTIONS;\n\t\tthis.options = options;\n\t\tthis.aggregateTimeout =\n\t\t\ttypeof options.aggregateTimeout === \"number\"\n\t\t\t\t? options.aggregateTimeout\n\t\t\t\t: 200;\n\t\tthis.watcherOptions = cachedNormalizeOptions(options);\n\t\tthis.watcherManager = getWatcherManager(this.watcherOptions);\n\t\tthis.fileWatchers = new Map();\n\t\tthis.directoryWatchers = new Map();\n\t\tthis._missing = new Set();\n\t\tthis.startTime = undefined;\n\t\tthis.paused = false;\n\t\tthis.aggregatedChanges = new Set();\n\t\tthis.aggregatedRemovals = new Set();\n\t\tthis.aggregateTimer = undefined;\n\t\tthis._onTimeout = this._onTimeout.bind(this);\n\t}\n\n\twatch(arg1, arg2, arg3) {\n\t\tlet files, directories, missing, startTime;\n\t\tif (!arg2) {\n\t\t\t({\n\t\t\t\tfiles = EMPTY_ARRAY,\n\t\t\t\tdirectories = EMPTY_ARRAY,\n\t\t\t\tmissing = EMPTY_ARRAY,\n\t\t\t\tstartTime\n\t\t\t} = arg1);\n\t\t} else {\n\t\t\tfiles = arg1;\n\t\t\tdirectories = arg2;\n\t\t\tmissing = EMPTY_ARRAY;\n\t\t\tstartTime = arg3;\n\t\t}\n\t\tthis.paused = false;\n\t\tconst fileWatchers = this.fileWatchers;\n\t\tconst directoryWatchers = this.directoryWatchers;\n\t\tconst ignored = this.watcherOptions.ignored;\n\t\tconst filter = path => !ignored(path);\n\t\tconst addToMap = (map, key, item) => {\n\t\t\tconst list = map.get(key);\n\t\t\tif (list === undefined) {\n\t\t\t\tmap.set(key, item);\n\t\t\t} else if (Array.isArray(list)) {\n\t\t\t\tlist.push(item);\n\t\t\t} else {\n\t\t\t\tmap.set(key, [list, item]);\n\t\t\t}\n\t\t};\n\t\tconst fileWatchersNeeded = new Map();\n\t\tconst directoryWatchersNeeded = new Map();\n\t\tconst missingFiles = new Set();\n\t\tif (this.watcherOptions.followSymlinks) {\n\t\t\tconst resolver = new LinkResolver();\n\t\t\tfor (const file of files) {\n\t\t\t\tif (filter(file)) {\n\t\t\t\t\tfor (const innerFile of resolver.resolve(file)) {\n\t\t\t\t\t\tif (file === innerFile || filter(innerFile)) {\n\t\t\t\t\t\t\taddToMap(fileWatchersNeeded, innerFile, file);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const file of missing) {\n\t\t\t\tif (filter(file)) {\n\t\t\t\t\tfor (const innerFile of resolver.resolve(file)) {\n\t\t\t\t\t\tif (file === innerFile || filter(innerFile)) {\n\t\t\t\t\t\t\tmissingFiles.add(file);\n\t\t\t\t\t\t\taddToMap(fileWatchersNeeded, innerFile, file);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const dir of directories) {\n\t\t\t\tif (filter(dir)) {\n\t\t\t\t\tlet first = true;\n\t\t\t\t\tfor (const innerItem of resolver.resolve(dir)) {\n\t\t\t\t\t\tif (filter(innerItem)) {\n\t\t\t\t\t\t\taddToMap(\n\t\t\t\t\t\t\t\tfirst ? directoryWatchersNeeded : fileWatchersNeeded,\n\t\t\t\t\t\t\t\tinnerItem,\n\t\t\t\t\t\t\t\tdir\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const file of files) {\n\t\t\t\tif (filter(file)) {\n\t\t\t\t\taddToMap(fileWatchersNeeded, file, file);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const file of missing) {\n\t\t\t\tif (filter(file)) {\n\t\t\t\t\tmissingFiles.add(file);\n\t\t\t\t\taddToMap(fileWatchersNeeded, file, file);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const dir of directories) {\n\t\t\t\tif (filter(dir)) {\n\t\t\t\t\taddToMap(directoryWatchersNeeded, dir, dir);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Close unneeded old watchers\n\t\t// and update existing watchers\n\t\tfor (const [key, w] of fileWatchers) {\n\t\t\tconst needed = fileWatchersNeeded.get(key);\n\t\t\tif (needed === undefined) {\n\t\t\t\tw.close();\n\t\t\t\tfileWatchers.delete(key);\n\t\t\t} else {\n\t\t\t\tw.update(needed);\n\t\t\t\tfileWatchersNeeded.delete(key);\n\t\t\t}\n\t\t}\n\t\tfor (const [key, w] of directoryWatchers) {\n\t\t\tconst needed = directoryWatchersNeeded.get(key);\n\t\t\tif (needed === undefined) {\n\t\t\t\tw.close();\n\t\t\t\tdirectoryWatchers.delete(key);\n\t\t\t} else {\n\t\t\t\tw.update(needed);\n\t\t\t\tdirectoryWatchersNeeded.delete(key);\n\t\t\t}\n\t\t}\n\t\t// Create new watchers and install handlers on these watchers\n\t\twatchEventSource.batch(() => {\n\t\t\tfor (const [key, files] of fileWatchersNeeded) {\n\t\t\t\tconst watcher = this.watcherManager.watchFile(key, startTime);\n\t\t\t\tif (watcher) {\n\t\t\t\t\tfileWatchers.set(key, new WatchpackFileWatcher(this, watcher, files));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const [key, directories] of directoryWatchersNeeded) {\n\t\t\t\tconst watcher = this.watcherManager.watchDirectory(key, startTime);\n\t\t\t\tif (watcher) {\n\t\t\t\t\tdirectoryWatchers.set(\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tnew WatchpackDirectoryWatcher(this, watcher, directories)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis._missing = missingFiles;\n\t\tthis.startTime = startTime;\n\t}\n\n\tclose() {\n\t\tthis.paused = true;\n\t\tif (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n\t\tfor (const w of this.fileWatchers.values()) w.close();\n\t\tfor (const w of this.directoryWatchers.values()) w.close();\n\t\tthis.fileWatchers.clear();\n\t\tthis.directoryWatchers.clear();\n\t}\n\n\tpause() {\n\t\tthis.paused = true;\n\t\tif (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n\t}\n\n\tgetTimes() {\n\t\tconst directoryWatchers = new Set();\n\t\taddWatchersToSet(this.fileWatchers.values(), directoryWatchers);\n\t\taddWatchersToSet(this.directoryWatchers.values(), directoryWatchers);\n\t\tconst obj = Object.create(null);\n\t\tfor (const w of directoryWatchers) {\n\t\t\tconst times = w.getTimes();\n\t\t\tfor (const file of Object.keys(times)) obj[file] = times[file];\n\t\t}\n\t\treturn obj;\n\t}\n\n\tgetTimeInfoEntries() {\n\t\tconst map = new Map();\n\t\tthis.collectTimeInfoEntries(map, map);\n\t\treturn map;\n\t}\n\n\tcollectTimeInfoEntries(fileTimestamps, directoryTimestamps) {\n\t\tconst allWatchers = new Set();\n\t\taddWatchersToSet(this.fileWatchers.values(), allWatchers);\n\t\taddWatchersToSet(this.directoryWatchers.values(), allWatchers);\n\t\tconst safeTime = { value: 0 };\n\t\tfor (const w of allWatchers) {\n\t\t\tw.collectTimeInfoEntries(fileTimestamps, directoryTimestamps, safeTime);\n\t\t}\n\t}\n\n\tgetAggregated() {\n\t\tif (this.aggregateTimer) {\n\t\t\tclearTimeout(this.aggregateTimer);\n\t\t\tthis.aggregateTimer = undefined;\n\t\t}\n\t\tconst changes = this.aggregatedChanges;\n\t\tconst removals = this.aggregatedRemovals;\n\t\tthis.aggregatedChanges = new Set();\n\t\tthis.aggregatedRemovals = new Set();\n\t\treturn { changes, removals };\n\t}\n\n\t_onChange(item, mtime, file, type) {\n\t\tfile = file || item;\n\t\tif (!this.paused) {\n\t\t\tthis.emit(\"change\", file, mtime, type);\n\t\t\tif (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n\t\t\tthis.aggregateTimer = setTimeout(this._onTimeout, this.aggregateTimeout);\n\t\t}\n\t\tthis.aggregatedRemovals.delete(item);\n\t\tthis.aggregatedChanges.add(item);\n\t}\n\n\t_onRemove(item, file, type) {\n\t\tfile = file || item;\n\t\tif (!this.paused) {\n\t\t\tthis.emit(\"remove\", file, type);\n\t\t\tif (this.aggregateTimer) clearTimeout(this.aggregateTimer);\n\t\t\tthis.aggregateTimer = setTimeout(this._onTimeout, this.aggregateTimeout);\n\t\t}\n\t\tthis.aggregatedChanges.delete(item);\n\t\tthis.aggregatedRemovals.add(item);\n\t}\n\n\t_onTimeout() {\n\t\tthis.aggregateTimer = undefined;\n\t\tconst changes = this.aggregatedChanges;\n\t\tconst removals = this.aggregatedRemovals;\n\t\tthis.aggregatedChanges = new Set();\n\t\tthis.aggregatedRemovals = new Set();\n\t\tthis.emit(\"aggregated\", changes, removals);\n\t}\n}\n\nmodule.exports = Watchpack;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst path = require(\"path\");\nconst DirectoryWatcher = require(\"./DirectoryWatcher\");\n\nclass WatcherManager {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t\tthis.directoryWatchers = new Map();\n\t}\n\n\tgetDirectoryWatcher(directory) {\n\t\tconst watcher = this.directoryWatchers.get(directory);\n\t\tif (watcher === undefined) {\n\t\t\tconst newWatcher = new DirectoryWatcher(this, directory, this.options);\n\t\t\tthis.directoryWatchers.set(directory, newWatcher);\n\t\t\tnewWatcher.on(\"closed\", () => {\n\t\t\t\tthis.directoryWatchers.delete(directory);\n\t\t\t});\n\t\t\treturn newWatcher;\n\t\t}\n\t\treturn watcher;\n\t}\n\n\twatchFile(p, startTime) {\n\t\tconst directory = path.dirname(p);\n\t\tif (directory === p) return null;\n\t\treturn this.getDirectoryWatcher(directory).watch(p, startTime);\n\t}\n\n\twatchDirectory(directory, startTime) {\n\t\treturn this.getDirectoryWatcher(directory).watch(directory, startTime);\n\t}\n}\n\nconst watcherManagers = new WeakMap();\n/**\n * @param {object} options options\n * @returns {WatcherManager} the watcher manager\n */\nmodule.exports = options => {\n\tconst watcherManager = watcherManagers.get(options);\n\tif (watcherManager !== undefined) return watcherManager;\n\tconst newWatcherManager = new WatcherManager(options);\n\twatcherManagers.set(options, newWatcherManager);\n\treturn newWatcherManager;\n};\nmodule.exports.WatcherManager = WatcherManager;\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst EventEmitter = require(\"events\").EventEmitter;\nconst fs = require(\"graceful-fs\");\nconst path = require(\"path\");\n\nconst watchEventSource = require(\"./watchEventSource\");\n\nconst EXISTANCE_ONLY_TIME_ENTRY = Object.freeze({});\n\nlet FS_ACCURACY = 1000;\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst WATCHPACK_POLLING = process.env.WATCHPACK_POLLING;\nconst FORCE_POLLING =\n\t`${+WATCHPACK_POLLING}` === WATCHPACK_POLLING\n\t\t? +WATCHPACK_POLLING\n\t\t: !!WATCHPACK_POLLING && WATCHPACK_POLLING !== \"false\";\n\nfunction withoutCase(str) {\n\treturn str.toLowerCase();\n}\n\nfunction needCalls(times, callback) {\n\treturn function() {\n\t\tif (--times === 0) {\n\t\t\treturn callback();\n\t\t}\n\t};\n}\n\nclass Watcher extends EventEmitter {\n\tconstructor(directoryWatcher, filePath, startTime) {\n\t\tsuper();\n\t\tthis.directoryWatcher = directoryWatcher;\n\t\tthis.path = filePath;\n\t\tthis.startTime = startTime && +startTime;\n\t}\n\n\tcheckStartTime(mtime, initial) {\n\t\tconst startTime = this.startTime;\n\t\tif (typeof startTime !== \"number\") return !initial;\n\t\treturn startTime <= mtime;\n\t}\n\n\tclose() {\n\t\tthis.emit(\"closed\");\n\t}\n}\n\nclass DirectoryWatcher extends EventEmitter {\n\tconstructor(watcherManager, directoryPath, options) {\n\t\tsuper();\n\t\tif (FORCE_POLLING) {\n\t\t\toptions.poll = FORCE_POLLING;\n\t\t}\n\t\tthis.watcherManager = watcherManager;\n\t\tthis.options = options;\n\t\tthis.path = directoryPath;\n\t\t// safeTime is the point in time after which reading is safe to be unchanged\n\t\t// timestamp is a value that should be compared with another timestamp (mtime)\n\t\t/** @type {Map<string, { safeTime: number, timestamp: number }} */\n\t\tthis.files = new Map();\n\t\t/** @type {Map<string, number>} */\n\t\tthis.filesWithoutCase = new Map();\n\t\tthis.directories = new Map();\n\t\tthis.lastWatchEvent = 0;\n\t\tthis.initialScan = true;\n\t\tthis.ignored = options.ignored || (() => false);\n\t\tthis.nestedWatching = false;\n\t\tthis.polledWatching =\n\t\t\ttypeof options.poll === \"number\"\n\t\t\t\t? options.poll\n\t\t\t\t: options.poll\n\t\t\t\t? 5007\n\t\t\t\t: false;\n\t\tthis.timeout = undefined;\n\t\tthis.initialScanRemoved = new Set();\n\t\tthis.initialScanFinished = undefined;\n\t\t/** @type {Map<string, Set<Watcher>>} */\n\t\tthis.watchers = new Map();\n\t\tthis.parentWatcher = null;\n\t\tthis.refs = 0;\n\t\tthis._activeEvents = new Map();\n\t\tthis.closed = false;\n\t\tthis.scanning = false;\n\t\tthis.scanAgain = false;\n\t\tthis.scanAgainInitial = false;\n\n\t\tthis.createWatcher();\n\t\tthis.doScan(true);\n\t}\n\n\tcreateWatcher() {\n\t\ttry {\n\t\t\tif (this.polledWatching) {\n\t\t\t\tthis.watcher = {\n\t\t\t\t\tclose: () => {\n\t\t\t\t\t\tif (this.timeout) {\n\t\t\t\t\t\t\tclearTimeout(this.timeout);\n\t\t\t\t\t\t\tthis.timeout = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (IS_OSX) {\n\t\t\t\t\tthis.watchInParentDirectory();\n\t\t\t\t}\n\t\t\t\tthis.watcher = watchEventSource.watch(this.path);\n\t\t\t\tthis.watcher.on(\"change\", this.onWatchEvent.bind(this));\n\t\t\t\tthis.watcher.on(\"error\", this.onWatcherError.bind(this));\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthis.onWatcherError(err);\n\t\t}\n\t}\n\n\tforEachWatcher(path, fn) {\n\t\tconst watchers = this.watchers.get(withoutCase(path));\n\t\tif (watchers !== undefined) {\n\t\t\tfor (const w of watchers) {\n\t\t\t\tfn(w);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetMissing(itemPath, initial, type) {\n\t\tif (this.initialScan) {\n\t\t\tthis.initialScanRemoved.add(itemPath);\n\t\t}\n\n\t\tconst oldDirectory = this.directories.get(itemPath);\n\t\tif (oldDirectory) {\n\t\t\tif (this.nestedWatching) oldDirectory.close();\n\t\t\tthis.directories.delete(itemPath);\n\n\t\t\tthis.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", itemPath, null, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst oldFile = this.files.get(itemPath);\n\t\tif (oldFile) {\n\t\t\tthis.files.delete(itemPath);\n\t\t\tconst key = withoutCase(itemPath);\n\t\t\tconst count = this.filesWithoutCase.get(key) - 1;\n\t\t\tif (count <= 0) {\n\t\t\t\tthis.filesWithoutCase.delete(key);\n\t\t\t\tthis.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n\t\t\t} else {\n\t\t\t\tthis.filesWithoutCase.set(key, count);\n\t\t\t}\n\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", itemPath, null, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetFileTime(filePath, mtime, initial, ignoreWhenEqual, type) {\n\t\tconst now = Date.now();\n\n\t\tif (this.ignored(filePath)) return;\n\n\t\tconst old = this.files.get(filePath);\n\n\t\tlet safeTime, accuracy;\n\t\tif (initial) {\n\t\t\tsafeTime = Math.min(now, mtime) + FS_ACCURACY;\n\t\t\taccuracy = FS_ACCURACY;\n\t\t} else {\n\t\t\tsafeTime = now;\n\t\t\taccuracy = 0;\n\n\t\t\tif (old && old.timestamp === mtime && mtime + FS_ACCURACY < now - 1000) {\n\t\t\t\t// We are sure that mtime is untouched\n\t\t\t\t// This can be caused by some file attribute change\n\t\t\t\t// e. g. when access time has been changed\n\t\t\t\t// but the file content is untouched\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreWhenEqual && old && old.timestamp === mtime) return;\n\n\t\tthis.files.set(filePath, {\n\t\t\tsafeTime,\n\t\t\taccuracy,\n\t\t\ttimestamp: mtime\n\t\t});\n\n\t\tif (!old) {\n\t\t\tconst key = withoutCase(filePath);\n\t\t\tconst count = this.filesWithoutCase.get(key);\n\t\t\tthis.filesWithoutCase.set(key, (count || 0) + 1);\n\t\t\tif (count !== undefined) {\n\t\t\t\t// There is already a file with case-insensitive-equal name\n\t\t\t\t// On a case-insensitive filesystem we may miss the renaming\n\t\t\t\t// when only casing is changed.\n\t\t\t\t// To be sure that our information is correct\n\t\t\t\t// we trigger a rescan here\n\t\t\t\tthis.doScan(false);\n\t\t\t}\n\n\t\t\tthis.forEachWatcher(filePath, w => {\n\t\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\t\tw.emit(\"change\", mtime, type);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (!initial) {\n\t\t\tthis.forEachWatcher(filePath, w => w.emit(\"change\", mtime, type));\n\t\t}\n\t\tthis.forEachWatcher(this.path, w => {\n\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\tw.emit(\"change\", filePath, safeTime, type, initial);\n\t\t\t}\n\t\t});\n\t}\n\n\tsetDirectory(directoryPath, birthtime, initial, type) {\n\t\tif (this.ignored(directoryPath)) return;\n\t\tif (directoryPath === this.path) {\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", directoryPath, birthtime, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tconst old = this.directories.get(directoryPath);\n\t\t\tif (!old) {\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tif (this.nestedWatching) {\n\t\t\t\t\tthis.createNestedWatcher(directoryPath);\n\t\t\t\t} else {\n\t\t\t\t\tthis.directories.set(directoryPath, true);\n\t\t\t\t}\n\n\t\t\t\tlet safeTime;\n\t\t\t\tif (initial) {\n\t\t\t\t\tsafeTime = Math.min(now, birthtime) + FS_ACCURACY;\n\t\t\t\t} else {\n\t\t\t\t\tsafeTime = now;\n\t\t\t\t}\n\n\t\t\t\tthis.forEachWatcher(directoryPath, w => {\n\t\t\t\t\tif (!initial || w.checkStartTime(safeTime, false)) {\n\t\t\t\t\t\tw.emit(\"change\", birthtime, type);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis.forEachWatcher(this.path, w => {\n\t\t\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\t\t\tw.emit(\"change\", directoryPath, safeTime, type, initial);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateNestedWatcher(directoryPath) {\n\t\tconst watcher = this.watcherManager.watchDirectory(directoryPath, 1);\n\t\twatcher.on(\"change\", (filePath, mtime, type, initial) => {\n\t\t\tthis.forEachWatcher(this.path, w => {\n\t\t\t\tif (!initial || w.checkStartTime(mtime, initial)) {\n\t\t\t\t\tw.emit(\"change\", filePath, mtime, type, initial);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tthis.directories.set(directoryPath, watcher);\n\t}\n\n\tsetNestedWatching(flag) {\n\t\tif (this.nestedWatching !== !!flag) {\n\t\t\tthis.nestedWatching = !!flag;\n\t\t\tif (this.nestedWatching) {\n\t\t\t\tfor (const directory of this.directories.keys()) {\n\t\t\t\t\tthis.createNestedWatcher(directory);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const [directory, watcher] of this.directories) {\n\t\t\t\t\twatcher.close();\n\t\t\t\t\tthis.directories.set(directory, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twatch(filePath, startTime) {\n\t\tconst key = withoutCase(filePath);\n\t\tlet watchers = this.watchers.get(key);\n\t\tif (watchers === undefined) {\n\t\t\twatchers = new Set();\n\t\t\tthis.watchers.set(key, watchers);\n\t\t}\n\t\tthis.refs++;\n\t\tconst watcher = new Watcher(this, filePath, startTime);\n\t\twatcher.on(\"closed\", () => {\n\t\t\tif (--this.refs <= 0) {\n\t\t\t\tthis.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twatchers.delete(watcher);\n\t\t\tif (watchers.size === 0) {\n\t\t\t\tthis.watchers.delete(key);\n\t\t\t\tif (this.path === filePath) this.setNestedWatching(false);\n\t\t\t}\n\t\t});\n\t\twatchers.add(watcher);\n\t\tlet safeTime;\n\t\tif (filePath === this.path) {\n\t\t\tthis.setNestedWatching(true);\n\t\t\tsafeTime = this.lastWatchEvent;\n\t\t\tfor (const entry of this.files.values()) {\n\t\t\t\tfixupEntryAccuracy(entry);\n\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t}\n\t\t} else {\n\t\t\tconst entry = this.files.get(filePath);\n\t\t\tif (entry) {\n\t\t\t\tfixupEntryAccuracy(entry);\n\t\t\t\tsafeTime = entry.safeTime;\n\t\t\t} else {\n\t\t\t\tsafeTime = 0;\n\t\t\t}\n\t\t}\n\t\tif (safeTime) {\n\t\t\tif (safeTime >= startTime) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tif (filePath === this.path) {\n\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\"change\",\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\t\"watch (outdated on attach)\",\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\"change\",\n\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\t\"watch (outdated on attach)\",\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (this.initialScan) {\n\t\t\tif (this.initialScanRemoved.has(filePath)) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\twatcher.emit(\"remove\");\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (\n\t\t\t!this.directories.has(filePath) &&\n\t\t\twatcher.checkStartTime(this.initialScanFinished, false)\n\t\t) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\twatcher.emit(\"initial-missing\", \"watch (missing on attach)\");\n\t\t\t});\n\t\t}\n\t\treturn watcher;\n\t}\n\n\tonWatchEvent(eventType, filename) {\n\t\tif (this.closed) return;\n\t\tif (!filename) {\n\t\t\t// In some cases no filename is provided\n\t\t\t// This seem to happen on windows\n\t\t\t// So some event happened but we don't know which file is affected\n\t\t\t// We have to do a full scan of the directory\n\t\t\tthis.doScan(false);\n\t\t\treturn;\n\t\t}\n\n\t\tconst filePath = path.join(this.path, filename);\n\t\tif (this.ignored(filePath)) return;\n\n\t\tif (this._activeEvents.get(filename) === undefined) {\n\t\t\tthis._activeEvents.set(filename, false);\n\t\t\tconst checkStats = () => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tthis._activeEvents.set(filename, false);\n\t\t\t\tfs.lstat(filePath, (err, stats) => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tif (this._activeEvents.get(filename) === true) {\n\t\t\t\t\t\tprocess.nextTick(checkStats);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._activeEvents.delete(filename);\n\t\t\t\t\t// ENOENT happens when the file/directory doesn't exist\n\t\t\t\t\t// EPERM happens when the containing directory doesn't exist\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terr.code !== \"ENOENT\" &&\n\t\t\t\t\t\t\terr.code !== \"EPERM\" &&\n\t\t\t\t\t\t\terr.code !== \"EBUSY\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.onStatsError(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (filename === path.basename(this.path)) {\n\t\t\t\t\t\t\t\t// This may indicate that the directory itself was removed\n\t\t\t\t\t\t\t\tif (!fs.existsSync(this.path)) {\n\t\t\t\t\t\t\t\t\tthis.onDirectoryRemoved(\"stat failed\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastWatchEvent = Date.now();\n\t\t\t\t\tif (!stats) {\n\t\t\t\t\t\tthis.setMissing(filePath, false, eventType);\n\t\t\t\t\t} else if (stats.isDirectory()) {\n\t\t\t\t\t\tthis.setDirectory(\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t+stats.birthtime || 1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\teventType\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (stats.isFile() || stats.isSymbolicLink()) {\n\t\t\t\t\t\tif (stats.mtime) {\n\t\t\t\t\t\t\tensureFsAccuracy(stats.mtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.setFileTime(\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t+stats.mtime || +stats.ctime || 1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\teventType\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\tprocess.nextTick(checkStats);\n\t\t} else {\n\t\t\tthis._activeEvents.set(filename, true);\n\t\t}\n\t}\n\n\tonWatcherError(err) {\n\t\tif (this.closed) return;\n\t\tif (err) {\n\t\t\tif (err.code !== \"EPERM\" && err.code !== \"ENOENT\") {\n\t\t\t\tconsole.error(\"Watchpack Error (watcher): \" + err);\n\t\t\t}\n\t\t\tthis.onDirectoryRemoved(\"watch error\");\n\t\t}\n\t}\n\n\tonStatsError(err) {\n\t\tif (err) {\n\t\t\tconsole.error(\"Watchpack Error (stats): \" + err);\n\t\t}\n\t}\n\n\tonScanError(err) {\n\t\tif (err) {\n\t\t\tconsole.error(\"Watchpack Error (initial scan): \" + err);\n\t\t}\n\t\tthis.onScanFinished();\n\t}\n\n\tonScanFinished() {\n\t\tif (this.polledWatching) {\n\t\t\tthis.timeout = setTimeout(() => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tthis.doScan(false);\n\t\t\t}, this.polledWatching);\n\t\t}\n\t}\n\n\tonDirectoryRemoved(reason) {\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.close();\n\t\t\tthis.watcher = null;\n\t\t}\n\t\tthis.watchInParentDirectory();\n\t\tconst type = `directory-removed (${reason})`;\n\t\tfor (const directory of this.directories.keys()) {\n\t\t\tthis.setMissing(directory, null, type);\n\t\t}\n\t\tfor (const file of this.files.keys()) {\n\t\t\tthis.setMissing(file, null, type);\n\t\t}\n\t}\n\n\twatchInParentDirectory() {\n\t\tif (!this.parentWatcher) {\n\t\t\tconst parentDir = path.dirname(this.path);\n\t\t\t// avoid watching in the root directory\n\t\t\t// removing directories in the root directory is not supported\n\t\t\tif (path.dirname(parentDir) === parentDir) return;\n\n\t\t\tthis.parentWatcher = this.watcherManager.watchFile(this.path, 1);\n\t\t\tthis.parentWatcher.on(\"change\", (mtime, type) => {\n\t\t\t\tif (this.closed) return;\n\n\t\t\t\t// On non-osx platforms we don't need this watcher to detect\n\t\t\t\t// directory removal, as an EPERM error indicates that\n\t\t\t\tif ((!IS_OSX || this.polledWatching) && this.parentWatcher) {\n\t\t\t\t\tthis.parentWatcher.close();\n\t\t\t\t\tthis.parentWatcher = null;\n\t\t\t\t}\n\t\t\t\t// Try to create the watcher when parent directory is found\n\t\t\t\tif (!this.watcher) {\n\t\t\t\t\tthis.createWatcher();\n\t\t\t\t\tthis.doScan(false);\n\n\t\t\t\t\t// directory was created so we emit an event\n\t\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\t\tw.emit(\"change\", this.path, mtime, type, false)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.parentWatcher.on(\"remove\", () => {\n\t\t\t\tthis.onDirectoryRemoved(\"parent directory removed\");\n\t\t\t});\n\t\t}\n\t}\n\n\tdoScan(initial) {\n\t\tif (this.scanning) {\n\t\t\tif (this.scanAgain) {\n\t\t\t\tif (!initial) this.scanAgainInitial = false;\n\t\t\t} else {\n\t\t\t\tthis.scanAgain = true;\n\t\t\t\tthis.scanAgainInitial = initial;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.scanning = true;\n\t\tif (this.timeout) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = undefined;\n\t\t}\n\t\tprocess.nextTick(() => {\n\t\t\tif (this.closed) return;\n\t\t\tfs.readdir(this.path, (err, items) => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === \"ENOENT\" || err.code === \"EPERM\") {\n\t\t\t\t\t\tthis.onDirectoryRemoved(\"scan readdir failed\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.onScanError(err);\n\t\t\t\t\t}\n\t\t\t\t\tthis.initialScan = false;\n\t\t\t\t\tthis.initialScanFinished = Date.now();\n\t\t\t\t\tif (initial) {\n\t\t\t\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\t\t\t\tif (watcher.checkStartTime(this.initialScanFinished, false)) {\n\t\t\t\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\t\t\t\"initial-missing\",\n\t\t\t\t\t\t\t\t\t\t\"scan (parent directory missing in initial scan)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\t\tthis.doScan(this.scanAgainInitial);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.scanning = false;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst itemPaths = new Set(\n\t\t\t\t\titems.map(item => path.join(this.path, item.normalize(\"NFC\")))\n\t\t\t\t);\n\t\t\t\tfor (const file of this.files.keys()) {\n\t\t\t\t\tif (!itemPaths.has(file)) {\n\t\t\t\t\t\tthis.setMissing(file, initial, \"scan (missing)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const directory of this.directories.keys()) {\n\t\t\t\t\tif (!itemPaths.has(directory)) {\n\t\t\t\t\t\tthis.setMissing(directory, initial, \"scan (missing)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t// Early repeat of scan\n\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\tthis.doScan(initial);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst itemFinished = needCalls(itemPaths.size + 1, () => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tthis.initialScan = false;\n\t\t\t\t\tthis.initialScanRemoved = null;\n\t\t\t\t\tthis.initialScanFinished = Date.now();\n\t\t\t\t\tif (initial) {\n\t\t\t\t\t\tconst missingWatchers = new Map(this.watchers);\n\t\t\t\t\t\tmissingWatchers.delete(withoutCase(this.path));\n\t\t\t\t\t\tfor (const item of itemPaths) {\n\t\t\t\t\t\t\tmissingWatchers.delete(withoutCase(item));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const watchers of missingWatchers.values()) {\n\t\t\t\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\t\t\t\tif (watcher.checkStartTime(this.initialScanFinished, false)) {\n\t\t\t\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\t\t\t\"initial-missing\",\n\t\t\t\t\t\t\t\t\t\t\"scan (missing in initial scan)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\t\tthis.doScan(this.scanAgainInitial);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.scanning = false;\n\t\t\t\t\t\tthis.onScanFinished();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor (const itemPath of itemPaths) {\n\t\t\t\t\tfs.lstat(itemPath, (err2, stats) => {\n\t\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\t\tif (err2) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\terr2.code === \"ENOENT\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EPERM\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EACCES\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EBUSY\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.setMissing(itemPath, initial, \"scan (\" + err2.code + \")\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.onScanError(err2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titemFinished();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stats.isFile() || stats.isSymbolicLink()) {\n\t\t\t\t\t\t\tif (stats.mtime) {\n\t\t\t\t\t\t\t\tensureFsAccuracy(stats.mtime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.setFileTime(\n\t\t\t\t\t\t\t\titemPath,\n\t\t\t\t\t\t\t\t+stats.mtime || +stats.ctime || 1,\n\t\t\t\t\t\t\t\tinitial,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\"scan (file)\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (stats.isDirectory()) {\n\t\t\t\t\t\t\tif (!initial || !this.directories.has(itemPath))\n\t\t\t\t\t\t\t\tthis.setDirectory(\n\t\t\t\t\t\t\t\t\titemPath,\n\t\t\t\t\t\t\t\t\t+stats.birthtime || 1,\n\t\t\t\t\t\t\t\t\tinitial,\n\t\t\t\t\t\t\t\t\t\"scan (dir)\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\titemFinished();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\titemFinished();\n\t\t\t});\n\t\t});\n\t}\n\n\tgetTimes() {\n\t\tconst obj = Object.create(null);\n\t\tlet safeTime = this.lastWatchEvent;\n\t\tfor (const [file, entry] of this.files) {\n\t\t\tfixupEntryAccuracy(entry);\n\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\tobj[file] = Math.max(entry.safeTime, entry.timestamp);\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tconst times = w.directoryWatcher.getTimes();\n\t\t\t\tfor (const file of Object.keys(times)) {\n\t\t\t\t\tconst time = times[file];\n\t\t\t\t\tsafeTime = Math.max(safeTime, time);\n\t\t\t\t\tobj[file] = time;\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj[this.path] = safeTime;\n\t\t}\n\t\tif (!this.initialScan) {\n\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\tconst path = watcher.path;\n\t\t\t\t\tif (!Object.prototype.hasOwnProperty.call(obj, path)) {\n\t\t\t\t\t\tobj[path] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t}\n\n\tcollectTimeInfoEntries(fileTimestamps, directoryTimestamps) {\n\t\tlet safeTime = this.lastWatchEvent;\n\t\tfor (const [file, entry] of this.files) {\n\t\t\tfixupEntryAccuracy(entry);\n\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\tfileTimestamps.set(file, entry);\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tsafeTime = Math.max(\n\t\t\t\t\tsafeTime,\n\t\t\t\t\tw.directoryWatcher.collectTimeInfoEntries(\n\t\t\t\t\t\tfileTimestamps,\n\t\t\t\t\t\tdirectoryTimestamps\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\tdirectoryTimestamps.set(this.path, {\n\t\t\t\tsafeTime\n\t\t\t});\n\t\t} else {\n\t\t\tfor (const dir of this.directories.keys()) {\n\t\t\t\t// No additional info about this directory\n\t\t\t\t// but maybe another DirectoryWatcher has info\n\t\t\t\tfileTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\t\tif (!directoryTimestamps.has(dir))\n\t\t\t\t\tdirectoryTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\t}\n\t\t\tfileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\tdirectoryTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t}\n\t\tif (!this.initialScan) {\n\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\tconst path = watcher.path;\n\t\t\t\t\tif (!fileTimestamps.has(path)) {\n\t\t\t\t\t\tfileTimestamps.set(path, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn safeTime;\n\t}\n\n\tclose() {\n\t\tthis.closed = true;\n\t\tthis.initialScan = false;\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.close();\n\t\t\tthis.watcher = null;\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tw.close();\n\t\t\t}\n\t\t\tthis.directories.clear();\n\t\t}\n\t\tif (this.parentWatcher) {\n\t\t\tthis.parentWatcher.close();\n\t\t\tthis.parentWatcher = null;\n\t\t}\n\t\tthis.emit(\"closed\");\n\t}\n}\n\nmodule.exports = DirectoryWatcher;\nmodule.exports.EXISTANCE_ONLY_TIME_ENTRY = EXISTANCE_ONLY_TIME_ENTRY;\n\nfunction fixupEntryAccuracy(entry) {\n\tif (entry.accuracy > FS_ACCURACY) {\n\t\tentry.safeTime = entry.safeTime - entry.accuracy + FS_ACCURACY;\n\t\tentry.accuracy = FS_ACCURACY;\n\t}\n}\n\nfunction ensureFsAccuracy(mtime) {\n\tif (!mtime) return;\n\tif (FS_ACCURACY > 1 && mtime % 1 !== 0) FS_ACCURACY = 1;\n\telse if (FS_ACCURACY > 10 && mtime % 10 !== 0) FS_ACCURACY = 10;\n\telse if (FS_ACCURACY > 100 && mtime % 100 !== 0) FS_ACCURACY = 100;\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst { EventEmitter } = require(\"events\");\nconst reducePlan = require(\"./reducePlan\");\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst IS_WIN = require(\"os\").platform() === \"win32\";\nconst SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\n\nconst watcherLimit =\n\t+process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\n\nconst recursiveWatcherLogging = !!process.env\n\t.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\n\nlet isBatch = false;\nlet watcherCount = 0;\n\n/** @type {Map<Watcher, string>} */\nconst pendingWatchers = new Map();\n\n/** @type {Map<string, RecursiveWatcher>} */\nconst recursiveWatchers = new Map();\n\n/** @type {Map<string, DirectWatcher>} */\nconst directWatchers = new Map();\n\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\nconst underlyingWatcher = new Map();\n\nclass DirectWatcher {\n\tconstructor(filePath) {\n\t\tthis.filePath = filePath;\n\t\tthis.watchers = new Set();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(filePath);\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"change\", type, filename);\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t}\n\n\tadd(watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tthis.watchers.add(watcher);\n\t}\n\n\tremove(watcher) {\n\t\tthis.watchers.delete(watcher);\n\t\tif (this.watchers.size === 0) {\n\t\t\tdirectWatchers.delete(this.filePath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.watchers;\n\t}\n}\n\nclass RecursiveWatcher {\n\tconstructor(rootPath) {\n\t\tthis.rootPath = rootPath;\n\t\t/** @type {Map<Watcher, string>} */\n\t\tthis.mapWatcherToPath = new Map();\n\t\t/** @type {Map<string, Set<Watcher>>} */\n\t\tthis.mapPathToWatchers = new Map();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(rootPath, {\n\t\t\t\trecursive: true\n\t\t\t});\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tif (!filename) {\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) to all watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\t\tw.emit(\"change\", type);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst dir = path.dirname(filename);\n\t\t\t\t\tconst watchers = this.mapPathToWatchers.get(dir);\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) for '${filename}' to ${\n\t\t\t\t\t\t\t\twatchers ? watchers.size : 0\n\t\t\t\t\t\t\t} watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (watchers === undefined) return;\n\t\t\t\t\tfor (const w of watchers) {\n\t\t\t\t\t\tw.emit(\"change\", type, path.basename(filename));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t\tif (recursiveWatcherLogging) {\n\t\t\tprocess.stderr.write(\n\t\t\t\t`[watchpack] created recursive watcher at ${rootPath}\\n`\n\t\t\t);\n\t\t}\n\t}\n\n\tadd(filePath, watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tconst subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n\t\tthis.mapWatcherToPath.set(watcher, subpath);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tif (set === undefined) {\n\t\t\tconst newSet = new Set();\n\t\t\tnewSet.add(watcher);\n\t\t\tthis.mapPathToWatchers.set(subpath, newSet);\n\t\t} else {\n\t\t\tset.add(watcher);\n\t\t}\n\t}\n\n\tremove(watcher) {\n\t\tconst subpath = this.mapWatcherToPath.get(watcher);\n\t\tif (!subpath) return;\n\t\tthis.mapWatcherToPath.delete(watcher);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tset.delete(watcher);\n\t\tif (set.size === 0) {\n\t\t\tthis.mapPathToWatchers.delete(subpath);\n\t\t}\n\t\tif (this.mapWatcherToPath.size === 0) {\n\t\t\trecursiveWatchers.delete(this.rootPath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t`[watchpack] closed recursive watcher at ${this.rootPath}\\n`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.mapWatcherToPath;\n\t}\n}\n\nclass Watcher extends EventEmitter {\n\tclose() {\n\t\tif (pendingWatchers.has(this)) {\n\t\t\tpendingWatchers.delete(this);\n\t\t\treturn;\n\t\t}\n\t\tconst watcher = underlyingWatcher.get(this);\n\t\twatcher.remove(this);\n\t\tunderlyingWatcher.delete(this);\n\t}\n}\n\nconst createDirectWatcher = filePath => {\n\tconst existing = directWatchers.get(filePath);\n\tif (existing !== undefined) return existing;\n\tconst w = new DirectWatcher(filePath);\n\tdirectWatchers.set(filePath, w);\n\treturn w;\n};\n\nconst createRecursiveWatcher = rootPath => {\n\tconst existing = recursiveWatchers.get(rootPath);\n\tif (existing !== undefined) return existing;\n\tconst w = new RecursiveWatcher(rootPath);\n\trecursiveWatchers.set(rootPath, w);\n\treturn w;\n};\n\nconst execute = () => {\n\t/** @type {Map<string, Watcher[] | Watcher>} */\n\tconst map = new Map();\n\tconst addWatcher = (watcher, filePath) => {\n\t\tconst entry = map.get(filePath);\n\t\tif (entry === undefined) {\n\t\t\tmap.set(filePath, watcher);\n\t\t} else if (Array.isArray(entry)) {\n\t\t\tentry.push(watcher);\n\t\t} else {\n\t\t\tmap.set(filePath, [entry, watcher]);\n\t\t}\n\t};\n\tfor (const [watcher, filePath] of pendingWatchers) {\n\t\taddWatcher(watcher, filePath);\n\t}\n\tpendingWatchers.clear();\n\n\t// Fast case when we are not reaching the limit\n\tif (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n\t\t// Create watchers for all entries in the map\n\t\tfor (const [filePath, entry] of map) {\n\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\tif (Array.isArray(entry)) {\n\t\t\t\tfor (const item of entry) w.add(item);\n\t\t\t} else {\n\t\t\t\tw.add(entry);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// Reconsider existing watchers to improving watch plan\n\tfor (const watcher of recursiveWatchers.values()) {\n\t\tfor (const [w, subpath] of watcher.getWatchers()) {\n\t\t\taddWatcher(w, path.join(watcher.rootPath, subpath));\n\t\t}\n\t}\n\tfor (const watcher of directWatchers.values()) {\n\t\tfor (const w of watcher.getWatchers()) {\n\t\t\taddWatcher(w, watcher.filePath);\n\t\t}\n\t}\n\n\t// Merge map entries to keep watcher limit\n\t// Create a 10% buffer to be able to enter fast case more often\n\tconst plan = reducePlan(map, watcherLimit * 0.9);\n\n\t// Update watchers for all entries in the map\n\tfor (const [filePath, entry] of plan) {\n\t\tif (entry.size === 1) {\n\t\t\tfor (const [watcher, filePath] of entry) {\n\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\tif (old === w) continue;\n\t\t\t\tw.add(watcher);\n\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t}\n\t\t} else {\n\t\t\tconst filePaths = new Set(entry.values());\n\t\t\tif (filePaths.size > 1) {\n\t\t\t\tconst w = createRecursiveWatcher(filePath);\n\t\t\t\tfor (const [watcher, watcherPath] of entry) {\n\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\tw.add(watcherPath, watcher);\n\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const filePath of filePaths) {\n\t\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\t\tfor (const watcher of entry.keys()) {\n\t\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\t\tw.add(watcher);\n\t\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nexports.watch = filePath => {\n\tconst watcher = new Watcher();\n\t// Find an existing watcher\n\tconst directWatcher = directWatchers.get(filePath);\n\tif (directWatcher !== undefined) {\n\t\tdirectWatcher.add(watcher);\n\t\treturn watcher;\n\t}\n\tlet current = filePath;\n\tfor (;;) {\n\t\tconst recursiveWatcher = recursiveWatchers.get(current);\n\t\tif (recursiveWatcher !== undefined) {\n\t\t\trecursiveWatcher.add(filePath, watcher);\n\t\t\treturn watcher;\n\t\t}\n\t\tconst parent = path.dirname(current);\n\t\tif (parent === current) break;\n\t\tcurrent = parent;\n\t}\n\t// Queue up watcher for creation\n\tpendingWatchers.set(watcher, filePath);\n\tif (!isBatch) execute();\n\treturn watcher;\n};\n\nexports.batch = fn => {\n\tisBatch = true;\n\ttry {\n\t\tfn();\n\t} finally {\n\t\tisBatch = false;\n\t\texecute();\n\t}\n};\n\nexports.getNumberOfWatchers = () => {\n\treturn watcherCount;\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst path = require(\"path\");\n\n/**\n * @template T\n * @typedef {Object} TreeNode\n * @property {string} filePath\n * @property {TreeNode} parent\n * @property {TreeNode[]} children\n * @property {number} entries\n * @property {boolean} active\n * @property {T[] | T | undefined} value\n */\n\n/**\n * @template T\n * @param {Map<string, T[] | T} plan\n * @param {number} limit\n * @returns {Map<string, Map<T, string>>} the new plan\n */\nmodule.exports = (plan, limit) => {\n\tconst treeMap = new Map();\n\t// Convert to tree\n\tfor (const [filePath, value] of plan) {\n\t\ttreeMap.set(filePath, {\n\t\t\tfilePath,\n\t\t\tparent: undefined,\n\t\t\tchildren: undefined,\n\t\t\tentries: 1,\n\t\t\tactive: true,\n\t\t\tvalue\n\t\t});\n\t}\n\tlet currentCount = treeMap.size;\n\t// Create parents and calculate sum of entries\n\tfor (const node of treeMap.values()) {\n\t\tconst parentPath = path.dirname(node.filePath);\n\t\tif (parentPath !== node.filePath) {\n\t\t\tlet parent = treeMap.get(parentPath);\n\t\t\tif (parent === undefined) {\n\t\t\t\tparent = {\n\t\t\t\t\tfilePath: parentPath,\n\t\t\t\t\tparent: undefined,\n\t\t\t\t\tchildren: [node],\n\t\t\t\t\tentries: node.entries,\n\t\t\t\t\tactive: false,\n\t\t\t\t\tvalue: undefined\n\t\t\t\t};\n\t\t\t\ttreeMap.set(parentPath, parent);\n\t\t\t\tnode.parent = parent;\n\t\t\t} else {\n\t\t\t\tnode.parent = parent;\n\t\t\t\tif (parent.children === undefined) {\n\t\t\t\t\tparent.children = [node];\n\t\t\t\t} else {\n\t\t\t\t\tparent.children.push(node);\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tparent.entries += node.entries;\n\t\t\t\t\tparent = parent.parent;\n\t\t\t\t} while (parent);\n\t\t\t}\n\t\t}\n\t}\n\t// Reduce until limit reached\n\twhile (currentCount > limit) {\n\t\t// Select node that helps reaching the limit most effectively without overmerging\n\t\tconst overLimit = currentCount - limit;\n\t\tlet bestNode = undefined;\n\t\tlet bestCost = Infinity;\n\t\tfor (const node of treeMap.values()) {\n\t\t\tif (node.entries <= 1 || !node.children || !node.parent) continue;\n\t\t\tif (node.children.length === 0) continue;\n\t\t\tif (node.children.length === 1 && !node.value) continue;\n\t\t\t// Try to select the node with has just a bit more entries than we need to reduce\n\t\t\t// When just a bit more is over 30% over the limit,\n\t\t\t// also consider just a bit less entries then we need to reduce\n\t\t\tconst cost =\n\t\t\t\tnode.entries - 1 >= overLimit\n\t\t\t\t\t? node.entries - 1 - overLimit\n\t\t\t\t\t: overLimit - node.entries + 1 + limit * 0.3;\n\t\t\tif (cost < bestCost) {\n\t\t\t\tbestNode = node;\n\t\t\t\tbestCost = cost;\n\t\t\t}\n\t\t}\n\t\tif (!bestNode) break;\n\t\t// Merge all children\n\t\tconst reduction = bestNode.entries - 1;\n\t\tbestNode.active = true;\n\t\tbestNode.entries = 1;\n\t\tcurrentCount -= reduction;\n\t\tlet parent = bestNode.parent;\n\t\twhile (parent) {\n\t\t\tparent.entries -= reduction;\n\t\t\tparent = parent.parent;\n\t\t}\n\t\tconst queue = new Set(bestNode.children);\n\t\tfor (const node of queue) {\n\t\t\tnode.active = false;\n\t\t\tnode.entries = 0;\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) queue.add(child);\n\t\t\t}\n\t\t}\n\t}\n\t// Write down new plan\n\tconst newPlan = new Map();\n\tfor (const rootNode of treeMap.values()) {\n\t\tif (!rootNode.active) continue;\n\t\tconst map = new Map();\n\t\tconst queue = new Set([rootNode]);\n\t\tfor (const node of queue) {\n\t\t\tif (node.active && node !== rootNode) continue;\n\t\t\tif (node.value) {\n\t\t\t\tif (Array.isArray(node.value)) {\n\t\t\t\t\tfor (const item of node.value) {\n\t\t\t\t\t\tmap.set(item, node.filePath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmap.set(node.value, node.filePath);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tqueue.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnewPlan.set(rootNode.filePath, map);\n\t}\n\treturn newPlan;\n};\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\n// macOS, Linux, and Windows all rely on these errors\nconst EXPECTED_ERRORS = new Set([\"EINVAL\", \"ENOENT\"]);\n\n// On Windows there is also this error in some cases\nif (process.platform === \"win32\") EXPECTED_ERRORS.add(\"UNKNOWN\");\n\nclass LinkResolver {\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * @param {string} file path to file or directory\n\t * @returns {string[]} array of file and all symlinks contributed in the resolving process (first item is the resolved file)\n\t */\n\tresolve(file) {\n\t\tconst cacheEntry = this.cache.get(file);\n\t\tif (cacheEntry !== undefined) {\n\t\t\treturn cacheEntry;\n\t\t}\n\t\tconst parent = path.dirname(file);\n\t\tif (parent === file) {\n\t\t\t// At root of filesystem there can't be a link\n\t\t\tconst result = Object.freeze([file]);\n\t\t\tthis.cache.set(file, result);\n\t\t\treturn result;\n\t\t}\n\t\t// resolve the parent directory to find links there and get the real path\n\t\tconst parentResolved = this.resolve(parent);\n\t\tlet realFile = file;\n\n\t\t// is the parent directory really somewhere else?\n\t\tif (parentResolved[0] !== parent) {\n\t\t\t// get the real location of file\n\t\t\tconst basename = path.basename(file);\n\t\t\trealFile = path.resolve(parentResolved[0], basename);\n\t\t}\n\t\t// try to read the link content\n\t\ttry {\n\t\t\tconst linkContent = fs.readlinkSync(realFile);\n\n\t\t\t// resolve the link content relative to the parent directory\n\t\t\tconst resolvedLink = path.resolve(parentResolved[0], linkContent);\n\n\t\t\t// recursive resolve the link content for more links in the structure\n\t\t\tconst linkResolved = this.resolve(resolvedLink);\n\n\t\t\t// merge parent and link resolve results\n\t\t\tlet result;\n\t\t\tif (linkResolved.length > 1 && parentResolved.length > 1) {\n\t\t\t\t// when both contain links we need to duplicate them with a Set\n\t\t\t\tconst resultSet = new Set(linkResolved);\n\t\t\t\t// add the link\n\t\t\t\tresultSet.add(realFile);\n\t\t\t\t// add all symlinks of the parent\n\t\t\t\tfor (let i = 1; i < parentResolved.length; i++) {\n\t\t\t\t\tresultSet.add(parentResolved[i]);\n\t\t\t\t}\n\t\t\t\tresult = Object.freeze(Array.from(resultSet));\n\t\t\t} else if (parentResolved.length > 1) {\n\t\t\t\t// we have links in the parent but not for the link content location\n\t\t\t\tresult = parentResolved.slice();\n\t\t\t\tresult[0] = linkResolved[0];\n\t\t\t\t// add the link\n\t\t\t\tresult.push(realFile);\n\t\t\t\tObject.freeze(result);\n\t\t\t} else if (linkResolved.length > 1) {\n\t\t\t\t// we can return the link content location result\n\t\t\t\tresult = linkResolved.slice();\n\t\t\t\t// add the link\n\t\t\t\tresult.push(realFile);\n\t\t\t\tObject.freeze(result);\n\t\t\t} else {\n\t\t\t\t// neither link content location nor parent have links\n\t\t\t\t// this link is the only link here\n\t\t\t\tresult = Object.freeze([\n\t\t\t\t\t// the resolve real location\n\t\t\t\t\tlinkResolved[0],\n\t\t\t\t\t// add the link\n\t\t\t\t\trealFile\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis.cache.set(file, result);\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\tif (!EXPECTED_ERRORS.has(e.code)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\t// no link\n\t\t\tconst result = parentResolved.slice();\n\t\t\tresult[0] = realFile;\n\t\t\tObject.freeze(result);\n\t\t\tthis.cache.set(file, result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\nmodule.exports = LinkResolver;\n"]}