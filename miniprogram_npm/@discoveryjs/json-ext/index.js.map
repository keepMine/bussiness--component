{"version":3,"sources":["index.js","../package.json","stringify-info.js","utils.js","stringify-stream.js","parse-chunked.js","text-decoder.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,AENA,AHSA;AFOA,AIZA,AHSA,AENA,AENA,AHSA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = {\n    version: require('../package.json').version,\n    stringifyInfo: require('./stringify-info'),\n    stringifyStream: require('./stringify-stream'),\n    parseChunked: require('./parse-chunked')\n};\n","module.exports = {\n  \"_from\": \"@discoveryjs/json-ext@^0.5.0\",\n  \"_id\": \"@discoveryjs/json-ext@0.5.6\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha512-ws57AidsDvREKrZKYffXddNkyaF14iHNHm8VQnZH6t99E8gczjNN0GpvcGny0imC80yQ0tHz1xVUKk/KFQSUyA==\",\n  \"_location\": \"/@discoveryjs/json-ext\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"range\",\n    \"registry\": true,\n    \"raw\": \"@discoveryjs/json-ext@^0.5.0\",\n    \"name\": \"@discoveryjs/json-ext\",\n    \"escapedName\": \"@discoveryjs%2fjson-ext\",\n    \"scope\": \"@discoveryjs\",\n    \"rawSpec\": \"^0.5.0\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"^0.5.0\"\n  },\n  \"_requiredBy\": [\n    \"/webpack-cli\"\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/@discoveryjs/json-ext/-/json-ext-0.5.6.tgz\",\n  \"_shasum\": \"d5e0706cf8c6acd8c6032f8d54070af261bbbb2f\",\n  \"_spec\": \"@discoveryjs/json-ext@^0.5.0\",\n  \"_where\": \"/Users/wuliangjian/Desktop/myWork/mineUI/node_modules/webpack-cli\",\n  \"author\": {\n    \"name\": \"Roman Dvornov\",\n    \"email\": \"rdvornov@gmail.com\",\n    \"url\": \"https://github.com/lahmatiy\"\n  },\n  \"browser\": {\n    \"./src/stringify-stream.js\": \"./src/stringify-stream-browser.js\",\n    \"./src/text-decoder.js\": \"./src/text-decoder-browser.js\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/discoveryjs/json-ext/issues\"\n  },\n  \"bundleDependencies\": false,\n  \"dependencies\": {},\n  \"deprecated\": false,\n  \"description\": \"A set of utilities that extend the use of JSON\",\n  \"devDependencies\": {\n    \"@rollup/plugin-commonjs\": \"^15.1.0\",\n    \"@rollup/plugin-json\": \"^4.1.0\",\n    \"@rollup/plugin-node-resolve\": \"^9.0.0\",\n    \"chalk\": \"^4.1.0\",\n    \"coveralls\": \"^3.1.0\",\n    \"cross-env\": \"^7.0.3\",\n    \"eslint\": \"^7.6.0\",\n    \"mocha\": \"^8.1.1\",\n    \"nyc\": \"^15.1.0\",\n    \"rollup\": \"^2.28.2\",\n    \"rollup-plugin-terser\": \"^7.0.2\"\n  },\n  \"engines\": {\n    \"node\": \">=10.0.0\"\n  },\n  \"files\": [\n    \"dist\",\n    \"src\",\n    \"index.d.ts\"\n  ],\n  \"homepage\": \"https://github.com/discoveryjs/json-ext#readme\",\n  \"keywords\": [\n    \"json\",\n    \"utils\",\n    \"stream\",\n    \"async\",\n    \"promise\",\n    \"stringify\",\n    \"info\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"./src/index\",\n  \"name\": \"@discoveryjs/json-ext\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/discoveryjs/json-ext.git\"\n  },\n  \"scripts\": {\n    \"build\": \"rollup --config\",\n    \"build-and-test\": \"npm run build && npm run test:dist\",\n    \"coverage\": \"nyc npm test\",\n    \"coveralls\": \"nyc report --reporter=text-lcov | coveralls\",\n    \"lint\": \"eslint src test\",\n    \"lint-and-test\": \"npm run lint && npm test\",\n    \"prepublishOnly\": \"npm run build\",\n    \"test\": \"mocha --reporter progress\",\n    \"test:all\": \"npm run test:src && npm run test:dist\",\n    \"test:dist\": \"cross-env MODE=dist npm test && cross-env MODE=dist-min npm test\",\n    \"test:src\": \"npm test\",\n    \"travis\": \"nyc npm run lint-and-test && npm run build-and-test && npm run coveralls\"\n  },\n  \"types\": \"./index.d.ts\",\n  \"version\": \"0.5.6\"\n}\n","const {\n    normalizeReplacer,\n    normalizeSpace,\n    replaceValue,\n    getTypeNative,\n    getTypeAsync,\n    isLeadingSurrogate,\n    isTrailingSurrogate,\n    escapableCharCodeSubstitution,\n    type: {\n        PRIMITIVE,\n        OBJECT,\n        ARRAY,\n        PROMISE,\n        STRING_STREAM,\n        OBJECT_STREAM\n    }\n} = require('./utils');\nconst charLength2048 = Array.from({ length: 2048 }).map((_, code) => {\n    if (escapableCharCodeSubstitution.hasOwnProperty(code)) {\n        return 2; // \\X\n    }\n\n    if (code < 0x20) {\n        return 6; // \\uXXXX\n    }\n\n    return code < 128 ? 1 : 2; // UTF8 bytes\n});\n\nfunction stringLength(str) {\n    let len = 0;\n    let prevLeadingSurrogate = false;\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        if (code < 2048) {\n            len += charLength2048[code];\n        } else if (isLeadingSurrogate(code)) {\n            len += 6; // \\uXXXX since no pair with trailing surrogate yet\n            prevLeadingSurrogate = true;\n            continue;\n        } else if (isTrailingSurrogate(code)) {\n            len = prevLeadingSurrogate\n                ? len - 2  // surrogate pair (4 bytes), since we calculate prev leading surrogate as 6 bytes, substruct 2 bytes\n                : len + 6; // \\uXXXX\n        } else {\n            len += 3; // code >= 2048 is 3 bytes length for UTF8\n        }\n\n        prevLeadingSurrogate = false;\n    }\n\n    return len + 2; // +2 for quotes\n}\n\nfunction primitiveLength(value) {\n    switch (typeof value) {\n        case 'string':\n            return stringLength(value);\n\n        case 'number':\n            return Number.isFinite(value) ? String(value).length : 4 /* null */;\n\n        case 'boolean':\n            return value ? 4 /* true */ : 5 /* false */;\n\n        case 'undefined':\n        case 'object':\n            return 4; /* null */\n\n        default:\n            return 0;\n    }\n}\n\nfunction spaceLength(space) {\n    space = normalizeSpace(space);\n    return typeof space === 'string' ? space.length : 0;\n}\n\nmodule.exports = function jsonStringifyInfo(value, replacer, space, options) {\n    function walk(holder, key, value) {\n        if (stop) {\n            return;\n        }\n\n        value = replaceValue(holder, key, value, replacer);\n\n        let type = getType(value);\n\n        // check for circular structure\n        if (type !== PRIMITIVE && stack.has(value)) {\n            circular.add(value);\n            length += 4; // treat as null\n\n            if (!options.continueOnCircular) {\n                stop = true;\n            }\n\n            return;\n        }\n\n        switch (type) {\n            case PRIMITIVE:\n                if (value !== undefined || Array.isArray(holder)) {\n                    length += primitiveLength(value);\n                } else if (holder === root) {\n                    length += 9; // FIXME: that's the length of undefined, should we normalize behaviour to convert it to null?\n                }\n                break;\n\n            case OBJECT: {\n                if (visited.has(value)) {\n                    duplicate.add(value);\n                    length += visited.get(value);\n                    break;\n                }\n\n                const valueLength = length;\n                let entries = 0;\n\n                length += 2; // {}\n\n                stack.add(value);\n\n                for (const key in value) {\n                    if (hasOwnProperty.call(value, key) && (allowlist === null || allowlist.has(key))) {\n                        const prevLength = length;\n                        walk(value, key, value[key]);\n\n                        if (prevLength !== length) {\n                            // value is printed\n                            length += stringLength(key) + 1; // \"key\":\n                            entries++;\n                        }\n                    }\n                }\n\n                if (entries > 1) {\n                    length += entries - 1; // commas\n                }\n\n                stack.delete(value);\n\n                if (space > 0 && entries > 0) {\n                    length += (1 + (stack.size + 1) * space + 1) * entries; // for each key-value: \\n{space}\n                    length += 1 + stack.size * space; // for }\n                }\n\n                visited.set(value, length - valueLength);\n\n                break;\n            }\n\n            case ARRAY: {\n                if (visited.has(value)) {\n                    duplicate.add(value);\n                    length += visited.get(value);\n                    break;\n                }\n\n                const valueLength = length;\n\n                length += 2; // []\n\n                stack.add(value);\n\n                for (let i = 0; i < value.length; i++) {\n                    walk(value, i, value[i]);\n                }\n\n                if (value.length > 1) {\n                    length += value.length - 1; // commas\n                }\n\n                stack.delete(value);\n\n                if (space > 0 && value.length > 0) {\n                    length += (1 + (stack.size + 1) * space) * value.length; // for each element: \\n{space}\n                    length += 1 + stack.size * space; // for ]\n                }\n\n                visited.set(value, length - valueLength);\n\n                break;\n            }\n\n            case PROMISE:\n            case STRING_STREAM:\n                async.add(value);\n                break;\n\n            case OBJECT_STREAM:\n                length += 2; // []\n                async.add(value);\n                break;\n        }\n    }\n\n    let allowlist = null;\n    replacer = normalizeReplacer(replacer);\n\n    if (Array.isArray(replacer)) {\n        allowlist = new Set(replacer);\n        replacer = null;\n    }\n\n    space = spaceLength(space);\n    options = options || {};\n\n    const visited = new Map();\n    const stack = new Set();\n    const duplicate = new Set();\n    const circular = new Set();\n    const async = new Set();\n    const getType = options.async ? getTypeAsync : getTypeNative;\n    const root = { '': value };\n    let stop = false;\n    let length = 0;\n\n    walk(root, '', value);\n\n    return {\n        minLength: isNaN(length) ? Infinity : length,\n        circular: [...circular],\n        duplicate: [...duplicate],\n        async: [...async]\n    };\n};\n","const PrimitiveType = 1;\nconst ObjectType = 2;\nconst ArrayType = 3;\nconst PromiseType = 4;\nconst ReadableStringType = 5;\nconst ReadableObjectType = 6;\n// https://tc39.es/ecma262/#table-json-single-character-escapes\nconst escapableCharCodeSubstitution = { // JSON Single Character Escape Sequences\n    0x08: '\\\\b',\n    0x09: '\\\\t',\n    0x0a: '\\\\n',\n    0x0c: '\\\\f',\n    0x0d: '\\\\r',\n    0x22: '\\\\\\\"',\n    0x5c: '\\\\\\\\'\n};\n\nfunction isLeadingSurrogate(code) {\n    return code >= 0xD800 && code <= 0xDBFF;\n}\n\nfunction isTrailingSurrogate(code) {\n    return code >= 0xDC00 && code <= 0xDFFF;\n}\n\nfunction isReadableStream(value) {\n    return (\n        typeof value.pipe === 'function' &&\n        typeof value._read === 'function' &&\n        typeof value._readableState === 'object' && value._readableState !== null\n    );\n}\n\nfunction replaceValue(holder, key, value, replacer) {\n    if (value && typeof value.toJSON === 'function') {\n        value = value.toJSON();\n    }\n\n    if (replacer !== null) {\n        value = replacer.call(holder, String(key), value);\n    }\n\n    switch (typeof value) {\n        case 'function':\n        case 'symbol':\n            value = undefined;\n            break;\n\n        case 'object':\n            if (value !== null) {\n                const cls = value.constructor;\n                if (cls === String || cls === Number || cls === Boolean) {\n                    value = value.valueOf();\n                }\n            }\n            break;\n    }\n\n    return value;\n}\n\nfunction getTypeNative(value) {\n    if (value === null || typeof value !== 'object') {\n        return PrimitiveType;\n    }\n\n    if (Array.isArray(value)) {\n        return ArrayType;\n    }\n\n    return ObjectType;\n}\n\nfunction getTypeAsync(value) {\n    if (value === null || typeof value !== 'object') {\n        return PrimitiveType;\n    }\n\n    if (typeof value.then === 'function') {\n        return PromiseType;\n    }\n\n    if (isReadableStream(value)) {\n        return value._readableState.objectMode ? ReadableObjectType : ReadableStringType;\n    }\n\n    if (Array.isArray(value)) {\n        return ArrayType;\n    }\n\n    return ObjectType;\n}\n\nfunction normalizeReplacer(replacer) {\n    if (typeof replacer === 'function') {\n        return replacer;\n    }\n\n    if (Array.isArray(replacer)) {\n        const allowlist = new Set(replacer\n            .map(item => {\n                const cls = item && item.constructor;\n                return cls === String || cls === Number ? String(item) : null;\n            })\n            .filter(item => typeof item === 'string')\n        );\n\n        return [...allowlist];\n    }\n\n    return null;\n}\n\nfunction normalizeSpace(space) {\n    if (typeof space === 'number') {\n        if (!Number.isFinite(space) || space < 1) {\n            return false;\n        }\n\n        return ' '.repeat(Math.min(space, 10));\n    }\n\n    if (typeof space === 'string') {\n        return space.slice(0, 10) || false;\n    }\n\n    return false;\n}\n\nmodule.exports = {\n    escapableCharCodeSubstitution,\n    isLeadingSurrogate,\n    isTrailingSurrogate,\n    type: {\n        PRIMITIVE: PrimitiveType,\n        PROMISE: PromiseType,\n        ARRAY: ArrayType,\n        OBJECT: ObjectType,\n        STRING_STREAM: ReadableStringType,\n        OBJECT_STREAM: ReadableObjectType\n    },\n\n    isReadableStream,\n    replaceValue,\n    getTypeNative,\n    getTypeAsync,\n    normalizeReplacer,\n    normalizeSpace\n};\n","const { Readable } = require('stream');\nconst {\n    normalizeReplacer,\n    normalizeSpace,\n    replaceValue,\n    getTypeAsync,\n    type: {\n        PRIMITIVE,\n        OBJECT,\n        ARRAY,\n        PROMISE,\n        STRING_STREAM,\n        OBJECT_STREAM\n    }\n} = require('./utils');\nconst noop = () => {};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n// TODO: Remove when drop support for Node.js 10\n// Node.js 10 has no well-formed JSON.stringify()\n// https://github.com/tc39/proposal-well-formed-stringify\n// Adopted code from https://bugs.chromium.org/p/v8/issues/detail?id=7782#c12\nconst wellformedStringStringify = JSON.stringify('\\ud800') === '\"\\\\ud800\"'\n    ? JSON.stringify\n    : s => JSON.stringify(s).replace(\n        /\\p{Surrogate}/gu,\n        m => `\\\\u${m.charCodeAt(0).toString(16)}`\n    );\n\nfunction push() {\n    this.push(this._stack.value);\n    this.popStack();\n}\n\nfunction pushPrimitive(value) {\n    switch (typeof value) {\n        case 'string':\n            this.push(this.encodeString(value));\n            break;\n\n        case 'number':\n            this.push(Number.isFinite(value) ? this.encodeNumber(value) : 'null');\n            break;\n\n        case 'boolean':\n            this.push(value ? 'true' : 'false');\n            break;\n\n        case 'undefined':\n        case 'object': // typeof null === 'object'\n            this.push('null');\n            break;\n\n        default:\n            this.destroy(new TypeError(`Do not know how to serialize a ${value.constructor && value.constructor.name || typeof value}`));\n    }\n}\n\nfunction processObjectEntry(key) {\n    const current = this._stack;\n\n    if (!current.first) {\n        current.first = true;\n    } else {\n        this.push(',');\n    }\n\n    if (this.space) {\n        this.push(`\\n${this.space.repeat(this._depth)}${this.encodeString(key)}: `);\n    } else {\n        this.push(this.encodeString(key) + ':');\n    }\n}\n\nfunction processObject() {\n    const current = this._stack;\n\n    // when no keys left, remove obj from stack\n    if (current.index === current.keys.length) {\n        if (this.space && current.first) {\n            this.push(`\\n${this.space.repeat(this._depth - 1)}}`);\n        } else {\n            this.push('}');\n        }\n\n        this.popStack();\n        return;\n    }\n\n    const key = current.keys[current.index];\n\n    this.processValue(current.value, key, current.value[key], processObjectEntry);\n    current.index++;\n}\n\nfunction processArrayItem(index) {\n    if (index !== 0) {\n        this.push(',');\n    }\n\n    if (this.space) {\n        this.push(`\\n${this.space.repeat(this._depth)}`);\n    }\n}\n\nfunction processArray() {\n    const current = this._stack;\n\n    if (current.index === current.value.length) {\n        if (this.space && current.index > 0) {\n            this.push(`\\n${this.space.repeat(this._depth - 1)}]`);\n        } else {\n            this.push(']');\n        }\n\n        this.popStack();\n        return;\n    }\n\n    this.processValue(current.value, current.index, current.value[current.index], processArrayItem);\n    current.index++;\n}\n\nfunction createStreamReader(fn) {\n    return function() {\n        const current = this._stack;\n        const data = current.value.read(this._readSize);\n\n        if (data !== null) {\n            current.first = false;\n            fn.call(this, data, current);\n        } else {\n            if ((current.first && !current.value._readableState.reading) || current.ended) {\n                this.popStack();\n            } else {\n                current.first = true;\n                current.awaiting = true;\n            }\n        }\n    };\n}\n\nconst processReadableObject = createStreamReader(function(data, current) {\n    this.processValue(current.value, current.index, data, processArrayItem);\n    current.index++;\n});\n\nconst processReadableString = createStreamReader(function(data) {\n    this.push(data);\n});\n\nclass JsonStringifyStream extends Readable {\n    constructor(value, replacer, space) {\n        super({\n            autoDestroy: true\n        });\n\n        this.getKeys = Object.keys;\n        this.replacer = normalizeReplacer(replacer);\n\n        if (Array.isArray(this.replacer)) {\n            const allowlist = this.replacer;\n\n            this.getKeys = (value) => allowlist.filter(key => hasOwnProperty.call(value, key));\n            this.replacer = null;\n        }\n\n        this.space = normalizeSpace(space);\n        this._depth = 0;\n\n        this.error = null;\n        this._processing = false;\n        this._ended = false;\n\n        this._readSize = 0;\n        this._buffer = '';\n\n        this._stack = null;\n        this._visited = new WeakSet();\n\n        this.pushStack({\n            handler: () => {\n                this.popStack();\n                this.processValue({ '': value }, '', value, noop);\n            }\n        });\n    }\n\n    encodeString(value) {\n        if (/[^\\x20-\\uD799]|[\\x22\\x5c]/.test(value)) {\n            return wellformedStringStringify(value);\n        }\n\n        return '\"' + value + '\"';\n    }\n\n    encodeNumber(value) {\n        return value;\n    }\n\n    processValue(holder, key, value, callback) {\n        value = replaceValue(holder, key, value, this.replacer);\n\n        let type = getTypeAsync(value);\n\n        switch (type) {\n            case PRIMITIVE:\n                if (callback !== processObjectEntry || value !== undefined) {\n                    callback.call(this, key);\n                    pushPrimitive.call(this, value);\n                }\n                break;\n\n            case OBJECT:\n                callback.call(this, key);\n\n                // check for circular structure\n                if (this._visited.has(value)) {\n                    return this.destroy(new TypeError('Converting circular structure to JSON'));\n                }\n\n                this._visited.add(value);\n                this._depth++;\n                this.push('{');\n                this.pushStack({\n                    handler: processObject,\n                    value,\n                    index: 0,\n                    first: false,\n                    keys: this.getKeys(value)\n                });\n                break;\n\n            case ARRAY:\n                callback.call(this, key);\n\n                // check for circular structure\n                if (this._visited.has(value)) {\n                    return this.destroy(new TypeError('Converting circular structure to JSON'));\n                }\n\n                this._visited.add(value);\n\n                this.push('[');\n                this.pushStack({\n                    handler: processArray,\n                    value,\n                    index: 0\n                });\n                this._depth++;\n                break;\n\n            case PROMISE:\n                this.pushStack({\n                    handler: noop,\n                    awaiting: true\n                });\n\n                Promise.resolve(value)\n                    .then(resolved => {\n                        this.popStack();\n                        this.processValue(holder, key, resolved, callback);\n                        this.processStack();\n                    })\n                    .catch(error => {\n                        this.destroy(error);\n                    });\n                break;\n\n            case STRING_STREAM:\n            case OBJECT_STREAM:\n                callback.call(this, key);\n\n                // TODO: Remove when drop support for Node.js 10\n                // Used `_readableState.endEmitted` as fallback, since Node.js 10 has no `readableEnded` getter\n                if (value.readableEnded || value._readableState.endEmitted) {\n                    return this.destroy(new Error('Readable Stream has ended before it was serialized. All stream data have been lost'));\n                }\n\n                if (value.readableFlowing) {\n                    return this.destroy(new Error('Readable Stream is in flowing mode, data may have been lost. Trying to pause stream.'));\n                }\n\n                if (type === OBJECT_STREAM) {\n                    this.push('[');\n                    this.pushStack({\n                        handler: push,\n                        value: this.space ? '\\n' + this.space.repeat(this._depth) + ']' : ']'\n                    });\n                    this._depth++;\n                }\n\n                const self = this.pushStack({\n                    handler: type === OBJECT_STREAM ? processReadableObject : processReadableString,\n                    value,\n                    index: 0,\n                    first: false,\n                    ended: false,\n                    awaiting: !value.readable || value.readableLength === 0\n                });\n                const continueProcessing = () => {\n                    if (self.awaiting) {\n                        self.awaiting = false;\n                        this.processStack();\n                    }\n                };\n\n                value.once('error', error => this.destroy(error));\n                value.once('end', () => {\n                    self.ended = true;\n                    continueProcessing();\n                });\n                value.on('readable', continueProcessing);\n                break;\n        }\n    }\n\n    pushStack(node) {\n        node.prev = this._stack;\n        return this._stack = node;\n    }\n\n    popStack() {\n        const { handler, value } = this._stack;\n\n        if (handler === processObject || handler === processArray || handler === processReadableObject) {\n            this._visited.delete(value);\n            this._depth--;\n        }\n\n        this._stack = this._stack.prev;\n    }\n\n    processStack() {\n        if (this._processing || this._ended) {\n            return;\n        }\n\n        try {\n            this._processing = true;\n\n            while (this._stack !== null && !this._stack.awaiting) {\n                this._stack.handler.call(this);\n\n                if (!this._processing) {\n                    return;\n                }\n            }\n\n            this._processing = false;\n        } catch (error) {\n            this.destroy(error);\n            return;\n        }\n\n        if (this._stack === null && !this._ended) {\n            this._finish();\n            this.push(null);\n        }\n    }\n\n    push(data) {\n        if (data !== null) {\n            this._buffer += data;\n\n            // check buffer overflow\n            if (this._buffer.length < this._readSize) {\n                return;\n            }\n\n            // flush buffer\n            data = this._buffer;\n            this._buffer = '';\n            this._processing = false;\n        }\n\n        super.push(data);\n    }\n\n    _read(size) {\n        // start processing\n        this._readSize = size || this.readableHighWaterMark;\n        this.processStack();\n    }\n\n    _finish() {\n        this._ended = true;\n        this._processing = false;\n        this._stack = null;\n        this._visited = null;\n\n        if (this._buffer && this._buffer.length) {\n            super.push(this._buffer); // flush buffer\n        }\n\n        this._buffer = '';\n    }\n\n    _destroy(error, cb) {\n        this.error = this.error || error;\n        this._finish();\n        cb(error);\n    }\n}\n\nmodule.exports = function createJsonStringifyStream(value, replacer, space) {\n    return new JsonStringifyStream(value, replacer, space);\n};\n","const { isReadableStream } = require('./utils');\nconst TextDecoder = require('./text-decoder');\n\nconst STACK_OBJECT = 1;\nconst STACK_ARRAY = 2;\nconst decoder = new TextDecoder();\n\nfunction isObject(value) {\n    return value !== null && typeof value === 'object';\n}\n\nfunction adjustPosition(error, parser) {\n    if (error.name === 'SyntaxError' && parser.jsonParseOffset) {\n        error.message = error.message.replace(/at position (\\d+)/, (_, pos) =>\n            'at position ' + (Number(pos) + parser.jsonParseOffset)\n        );\n    }\n\n    return error;\n}\n\nfunction append(array, elements) {\n    // Note: Avoid to use array.push(...elements) since it may lead to\n    // \"RangeError: Maximum call stack size exceeded\" for a long arrays\n    const initialLength = array.length;\n    array.length += elements.length;\n\n    for (let i = 0; i < elements.length; i++) {\n        array[initialLength + i] = elements[i];\n    }\n}\n\nmodule.exports = function(chunkEmitter) {\n    let parser = new ChunkParser();\n\n    if (isObject(chunkEmitter) && isReadableStream(chunkEmitter)) {\n        return new Promise((resolve, reject) => {\n            chunkEmitter\n                .on('data', chunk => {\n                    try {\n                        parser.push(chunk);\n                    } catch (e) {\n                        reject(adjustPosition(e, parser));\n                        parser = null;\n                    }\n                })\n                .on('error', (e) => {\n                    parser = null;\n                    reject(e);\n                })\n                .on('end', () => {\n                    try {\n                        resolve(parser.finish());\n                    } catch (e) {\n                        reject(adjustPosition(e, parser));\n                    } finally {\n                        parser = null;\n                    }\n                });\n        });\n    }\n\n    if (typeof chunkEmitter === 'function') {\n        const iterator = chunkEmitter();\n\n        if (isObject(iterator) && (Symbol.iterator in iterator || Symbol.asyncIterator in iterator)) {\n            return new Promise(async (resolve, reject) => {\n                try {\n                    for await (const chunk of iterator) {\n                        parser.push(chunk);\n                    }\n\n                    resolve(parser.finish());\n                } catch (e) {\n                    reject(adjustPosition(e, parser));\n                } finally {\n                    parser = null;\n                }\n            });\n        }\n    }\n\n    throw new Error(\n        'Chunk emitter should be readable stream, generator, ' +\n        'async generator or function returning an iterable object'\n    );\n};\n\nclass ChunkParser {\n    constructor() {\n        this.value = undefined;\n        this.valueStack = null;\n\n        this.stack = new Array(100);\n        this.lastFlushDepth = 0;\n        this.flushDepth = 0;\n        this.stateString = false;\n        this.stateStringEscape = false;\n        this.pendingByteSeq = null;\n        this.pendingChunk = null;\n        this.chunkOffset = 0;\n        this.jsonParseOffset = 0;\n    }\n\n    parseAndAppend(fragment, wrap) {\n        // Append new entries or elements\n        if (this.stack[this.lastFlushDepth - 1] === STACK_OBJECT) {\n            if (wrap) {\n                this.jsonParseOffset--;\n                fragment = '{' + fragment + '}';\n            }\n\n            Object.assign(this.valueStack.value, JSON.parse(fragment));\n        } else {\n            if (wrap) {\n                this.jsonParseOffset--;\n                fragment = '[' + fragment + ']';\n            }\n\n            append(this.valueStack.value, JSON.parse(fragment));\n        }\n    }\n\n    prepareAddition(fragment) {\n        const { value } = this.valueStack;\n        const expectComma = Array.isArray(value)\n            ? value.length !== 0\n            : Object.keys(value).length !== 0;\n\n        if (expectComma) {\n            // Skip a comma at the beginning of fragment, otherwise it would\n            // fail to parse\n            if (fragment[0] === ',') {\n                this.jsonParseOffset++;\n                return fragment.slice(1);\n            }\n\n            // When value (an object or array) is not empty and a fragment\n            // doesn't start with a comma, a single valid fragment starting\n            // is a closing bracket. If it's not, a prefix is adding to fail\n            // parsing. Otherwise, the sequence of chunks can be successfully\n            // parsed, although it should not, e.g. [\"[{}\", \"{}]\"]\n            if (fragment[0] !== '}' && fragment[0] !== ']') {\n                this.jsonParseOffset -= 3;\n                return '[[]' + fragment;\n            }\n        }\n\n        return fragment;\n    }\n\n    flush(chunk, start, end) {\n        let fragment = chunk.slice(start, end);\n\n        // Save position correction an error in JSON.parse() if any\n        this.jsonParseOffset = this.chunkOffset + start;\n\n        // Prepend pending chunk if any\n        if (this.pendingChunk !== null) {\n            fragment = this.pendingChunk + fragment;\n            this.jsonParseOffset -= this.pendingChunk.length;\n            this.pendingChunk = null;\n        }\n\n        if (this.flushDepth === this.lastFlushDepth) {\n            // Depth didn't changed, so it's a root value or entry/element set\n            if (this.flushDepth > 0) {\n                this.parseAndAppend(this.prepareAddition(fragment), true);\n            } else {\n                // That's an entire value on a top level\n                this.value = JSON.parse(fragment);\n                this.valueStack = {\n                    value: this.value,\n                    prev: null\n                };\n            }\n        } else if (this.flushDepth > this.lastFlushDepth) {\n            // Add missed closing brackets/parentheses\n            for (let i = this.flushDepth - 1; i >= this.lastFlushDepth; i--) {\n                fragment += this.stack[i] === STACK_OBJECT ? '}' : ']';\n            }\n\n            if (this.lastFlushDepth === 0) {\n                // That's a root value\n                this.value = JSON.parse(fragment);\n                this.valueStack = {\n                    value: this.value,\n                    prev: null\n                };\n            } else {\n                this.parseAndAppend(this.prepareAddition(fragment), true);\n            }\n\n            // Move down to the depths to the last object/array, which is current now\n            for (let i = this.lastFlushDepth || 1; i < this.flushDepth; i++) {\n                let value = this.valueStack.value;\n\n                if (this.stack[i - 1] === STACK_OBJECT) {\n                    // find last entry\n                    let key;\n                    // eslint-disable-next-line curly\n                    for (key in value);\n                    value = value[key];\n                } else {\n                    // last element\n                    value = value[value.length - 1];\n                }\n\n                this.valueStack = {\n                    value,\n                    prev: this.valueStack\n                };\n            }\n        } else /* this.flushDepth < this.lastFlushDepth */ {\n            fragment = this.prepareAddition(fragment);\n\n            // Add missed opening brackets/parentheses\n            for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n                this.jsonParseOffset--;\n                fragment = (this.stack[i] === STACK_OBJECT ? '{' : '[') + fragment;\n            }\n\n            this.parseAndAppend(fragment, false);\n\n            for (let i = this.lastFlushDepth - 1; i >= this.flushDepth; i--) {\n                this.valueStack = this.valueStack.prev;\n            }\n        }\n\n        this.lastFlushDepth = this.flushDepth;\n    }\n\n    push(chunk) {\n        if (typeof chunk !== 'string') {\n            // Suppose chunk is Buffer or Uint8Array\n\n            // Prepend uncompleted byte sequence if any\n            if (this.pendingByteSeq !== null) {\n                const origRawChunk = chunk;\n                chunk = new Uint8Array(this.pendingByteSeq.length + origRawChunk.length);\n                chunk.set(this.pendingByteSeq);\n                chunk.set(origRawChunk, this.pendingByteSeq.length);\n                this.pendingByteSeq = null;\n            }\n\n            // In case Buffer/Uint8Array, an input is encoded in UTF8\n            // Seek for parts of uncompleted UTF8 symbol on the ending\n            // This makes sense only if we expect more chunks and last char is not multi-bytes\n            if (chunk[chunk.length - 1] > 127) {\n                for (let seqLength = 0; seqLength < chunk.length; seqLength++) {\n                    const byte = chunk[chunk.length - 1 - seqLength];\n\n                    // 10xxxxxx - 2nd, 3rd or 4th byte\n                    // 110xxxxx â€“ first byte of 2-byte sequence\n                    // 1110xxxx - first byte of 3-byte sequence\n                    // 11110xxx - first byte of 4-byte sequence\n                    if (byte >> 6 === 3) {\n                        seqLength++;\n\n                        // If the sequence is really incomplete, then preserve it\n                        // for the future chunk and cut off it from the current chunk\n                        if ((seqLength !== 4 && byte >> 3 === 0b11110) ||\n                            (seqLength !== 3 && byte >> 4 === 0b1110) ||\n                            (seqLength !== 2 && byte >> 5 === 0b110)) {\n                            this.pendingByteSeq = chunk.slice(chunk.length - seqLength);\n                            chunk = chunk.slice(0, -seqLength);\n                        }\n\n                        break;\n                    }\n                }\n            }\n\n            // Convert chunk to a string, since single decode per chunk\n            // is much effective than decode multiple small substrings\n            chunk = decoder.decode(chunk);\n        }\n\n        const chunkLength = chunk.length;\n        let lastFlushPoint = 0;\n        let flushPoint = 0;\n\n        // Main scan loop\n        scan: for (let i = 0; i < chunkLength; i++) {\n            if (this.stateString) {\n                for (; i < chunkLength; i++) {\n                    if (this.stateStringEscape) {\n                        this.stateStringEscape = false;\n                    } else {\n                        switch (chunk.charCodeAt(i)) {\n                            case 0x22: /* \" */\n                                this.stateString = false;\n                                continue scan;\n\n                            case 0x5C: /* \\ */\n                                this.stateStringEscape = true;\n                        }\n                    }\n                }\n\n                break;\n            }\n\n            switch (chunk.charCodeAt(i)) {\n                case 0x22: /* \" */\n                    this.stateString = true;\n                    this.stateStringEscape = false;\n                    break;\n\n                case 0x2C: /* , */\n                    flushPoint = i;\n                    break;\n\n                case 0x7B: /* { */\n                    // Open an object\n                    flushPoint = i + 1;\n                    this.stack[this.flushDepth++] = STACK_OBJECT;\n                    break;\n\n                case 0x5B: /* [ */\n                    // Open an array\n                    flushPoint = i + 1;\n                    this.stack[this.flushDepth++] = STACK_ARRAY;\n                    break;\n\n                case 0x5D: /* ] */\n                case 0x7D: /* } */\n                    // Close an object or array\n                    flushPoint = i + 1;\n                    this.flushDepth--;\n\n                    if (this.flushDepth < this.lastFlushDepth) {\n                        this.flush(chunk, lastFlushPoint, flushPoint);\n                        lastFlushPoint = flushPoint;\n                    }\n\n                    break;\n\n                case 0x09: /* \\t */\n                case 0x0A: /* \\n */\n                case 0x0D: /* \\r */\n                case 0x20: /* space */\n                    // Move points forward when they points on current position and it's a whitespace\n                    if (lastFlushPoint === i) {\n                        lastFlushPoint++;\n                    }\n\n                    if (flushPoint === i) {\n                        flushPoint++;\n                    }\n\n                    break;\n            }\n        }\n\n        if (flushPoint > lastFlushPoint) {\n            this.flush(chunk, lastFlushPoint, flushPoint);\n        }\n\n        // Produce pendingChunk if something left\n        if (flushPoint < chunkLength) {\n            if (this.pendingChunk !== null) {\n                // When there is already a pending chunk then no flush happened,\n                // appending entire chunk to pending one\n                this.pendingChunk += chunk;\n            } else {\n                // Create a pending chunk, it will start with non-whitespace since\n                // flushPoint was moved forward away from whitespaces on scan\n                this.pendingChunk = chunk.slice(flushPoint, chunkLength);\n            }\n        }\n\n        this.chunkOffset += chunkLength;\n    }\n\n    finish() {\n        if (this.pendingChunk !== null) {\n            this.flush('', 0, 0);\n            this.pendingChunk = null;\n        }\n\n        return this.value;\n    }\n};\n","module.exports = require('util').TextDecoder;\n"]}